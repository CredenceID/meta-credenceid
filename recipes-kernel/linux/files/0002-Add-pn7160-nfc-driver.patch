From 922325efa8793796e95b08afce210da444a96afa Mon Sep 17 00:00:00 2001
From: Pavan Nittala <Pavan.Nittala@credenceid.com>
Date: Thu, 23 Jan 2025 08:54:26 +0000
Subject: [PATCH] Add pn7160 nfc driver

---
 drivers/misc/Kconfig                       |   8 +
 drivers/misc/Makefile                      |   1 +
 drivers/misc/nxp-pn7160/Kconfig            |  34 ++
 drivers/misc/nxp-pn7160/LICENSE            | 340 ++++++++++++
 drivers/misc/nxp-pn7160/Makefile           |   4 +
 drivers/misc/nxp-pn7160/README.md          |   2 +
 drivers/misc/nxp-pn7160/i2c_devicetree.txt |  12 +
 drivers/misc/nxp-pn7160/nfc/Makefile       |   8 +
 drivers/misc/nxp-pn7160/nfc/common.c       | 370 +++++++++++++
 drivers/misc/nxp-pn7160/nfc/common.h       | 208 ++++++++
 drivers/misc/nxp-pn7160/nfc/i2c_drv.c      | 488 +++++++++++++++++
 drivers/misc/nxp-pn7160/nfc/i2c_drv.h      |  46 ++
 drivers/misc/nxp-pn7160/nfc/spi_drv.c      | 586 +++++++++++++++++++++
 drivers/misc/nxp-pn7160/nfc/spi_drv.h      |  56 ++
 drivers/misc/nxp-pn7160/spi_devicetree.txt |  13 +
 15 files changed, 2176 insertions(+)
 create mode 100644 drivers/misc/nxp-pn7160/Kconfig
 create mode 100644 drivers/misc/nxp-pn7160/LICENSE
 create mode 100644 drivers/misc/nxp-pn7160/Makefile
 create mode 100644 drivers/misc/nxp-pn7160/README.md
 create mode 100644 drivers/misc/nxp-pn7160/i2c_devicetree.txt
 create mode 100755 drivers/misc/nxp-pn7160/nfc/Makefile
 create mode 100755 drivers/misc/nxp-pn7160/nfc/common.c
 create mode 100755 drivers/misc/nxp-pn7160/nfc/common.h
 create mode 100755 drivers/misc/nxp-pn7160/nfc/i2c_drv.c
 create mode 100755 drivers/misc/nxp-pn7160/nfc/i2c_drv.h
 create mode 100755 drivers/misc/nxp-pn7160/nfc/spi_drv.c
 create mode 100755 drivers/misc/nxp-pn7160/nfc/spi_drv.h
 create mode 100644 drivers/misc/nxp-pn7160/spi_devicetree.txt

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 3ae5aa9319f2..ec651a61dd97 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -352,6 +352,14 @@ config SENSORS_APDS990X
 	   To compile this driver as a module, choose M here: the
 	   module will be called apds990x. If unsure, say N here.
 
+config NXP_NFC_I2C
+	tristate "NXP pn7160 driver selection"
+	depends on I2C
+	default y
+	help
+	  This driver enable pn7160 controller with i2c interface
+
+
 config HMC6352
 	tristate "Honeywell HMC6352 compass"
 	depends on I2C
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index a1b5b9693a9b..0af46dfb1077 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -66,3 +66,4 @@ obj-$(CONFIG_GP_PCI1XXXX)	+= mchp_pci1xxxx/
 obj-$(CONFIG_VCPU_STALL_DETECTOR)	+= vcpu_stall_detector.o
 obj-$(CONFIG_WIEGAND)		+= wiegand.o
 obj-y				+= nxp-pn5xx/
+obj-y                          += nxp-pn7160/
diff --git a/drivers/misc/nxp-pn7160/Kconfig b/drivers/misc/nxp-pn7160/Kconfig
new file mode 100644
index 000000000000..d5b0bd8c036c
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/Kconfig
@@ -0,0 +1,34 @@
+#
+# near field communication configuration
+#
+
+config NXP_NFC_I2C
+	tristate "NFC I2C Slave driver for NXP-NFCC"
+	depends on I2C
+	help
+	  This enables the NFC driver for PN71xx based devices.
+	  This is for I2C connected version. NCI protocol logic
+	  resides in the usermode and it has no other NFC dependencies.
+
+	  If unsure, say N.
+
+config NXP_NFC_SPI
+	tristate "NFC SPI Slave driver for NXP-NFCC"
+	depends on SPI
+	help
+	  This enables the NFC driver for PN71xx based devices.
+	  This is for SPI connected version. NCI protocol logic
+	  resides in the usermode and it has no other NFC dependencies.
+
+	  If unsure, say N.
+
+
+config NXP_NFC_RECOVERY
+	bool "NXP based NFC minimal FW update support"
+	depends on NXP_NFC_I2C && I2C
+        default y
+	help
+	  This enables NFC minimal FW update.
+
+	  If unsure, say N.
+
diff --git a/drivers/misc/nxp-pn7160/LICENSE b/drivers/misc/nxp-pn7160/LICENSE
new file mode 100644
index 000000000000..8cdb8451d9b9
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/LICENSE
@@ -0,0 +1,340 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    {description}
+    Copyright (C) {year}  {fullname}
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  {signature of Ty Coon}, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
+
diff --git a/drivers/misc/nxp-pn7160/Makefile b/drivers/misc/nxp-pn7160/Makefile
new file mode 100644
index 000000000000..2a33c7332268
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/Makefile
@@ -0,0 +1,4 @@
+#
+# Makefile for the kernel nfc device drivers.
+#
+obj-y				+= nfc/
diff --git a/drivers/misc/nxp-pn7160/README.md b/drivers/misc/nxp-pn7160/README.md
new file mode 100644
index 000000000000..a8c9ef2edc7c
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/README.md
@@ -0,0 +1,2 @@
+# nxpnfc
+PN7160 NFC Open Source Kernel mode driver supporting both IÂ²C and SPI interfaces
\ No newline at end of file
diff --git a/drivers/misc/nxp-pn7160/i2c_devicetree.txt b/drivers/misc/nxp-pn7160/i2c_devicetree.txt
new file mode 100644
index 000000000000..b928139b1525
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/i2c_devicetree.txt
@@ -0,0 +1,12 @@
+Example:
+
+i2c0: i2c@ffd71000 {
+    status = "ok";
+    nxpnfc: nxpnfc@28 {
+        compatible = "nxp,nxpnfc";
+        reg = <0x28>;
+        nxp,nxpnfc-irq = <&gpio26 0 0>;
+        nxp,nxpnfc-ven = <&gpio26 2 0>;
+        nxp,nxpnfc-fw-dwnld = <&gpio26 4 0>;
+    };
+};
\ No newline at end of file
diff --git a/drivers/misc/nxp-pn7160/nfc/Makefile b/drivers/misc/nxp-pn7160/nfc/Makefile
new file mode 100755
index 000000000000..c31b9e0d0372
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/nfc/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for nfc devices
+#
+obj-$(CONFIG_NXP_NFC_I2C)		+= nxpnfc_i2c.o
+nxpnfc_i2c-objs				:= common.o i2c_drv.o
+obj-$(CONFIG_NXP_NFC_SPI)		+= nxpnfc_spi.o
+nxpnfc_spi-objs				:= common.o spi_drv.o
+#ccflags-y                      += -DDEBUG
diff --git a/drivers/misc/nxp-pn7160/nfc/common.c b/drivers/misc/nxp-pn7160/nfc/common.c
new file mode 100755
index 000000000000..0a305b751117
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/nfc/common.c
@@ -0,0 +1,370 @@
+/******************************************************************************
+ * Copyright (C) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2019-2021 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ******************************************************************************/
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+
+#include "common.h"
+
+int nfc_parse_dt(struct device *dev, struct platform_configs *nfc_configs,
+		 uint8_t interface)
+{
+	struct device_node *np = dev->of_node;
+	struct platform_gpio *nfc_gpio = &nfc_configs->gpio;
+
+	if (!np) {
+		pr_err("%s: nfc of_node NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	nfc_gpio->irq = -EINVAL;
+	nfc_gpio->dwl_req = -EINVAL;
+	nfc_gpio->ven = -EINVAL;
+
+	/* irq required for i2c based chips only */
+	if (interface == PLATFORM_IF_I2C || interface == PLATFORM_IF_SPI) {
+		nfc_gpio->irq = of_get_named_gpio(np, DTS_IRQ_GPIO_STR, 0);
+		if ((!gpio_is_valid(nfc_gpio->irq))) {
+			pr_err("%s: irq gpio invalid %d\n", __func__,
+			       nfc_gpio->irq);
+			return -EINVAL;
+		}
+		pr_info("%s: irq %d\n", __func__, nfc_gpio->irq);
+	}
+	nfc_gpio->ven = of_get_named_gpio(np, DTS_VEN_GPIO_STR, 0);
+	if ((!gpio_is_valid(nfc_gpio->ven))) {
+		pr_err("%s: ven gpio invalid %d\n", __func__, nfc_gpio->ven);
+		return -EINVAL;
+	}
+	/* some products like sn220 does not required fw dwl pin */
+	nfc_gpio->dwl_req = of_get_named_gpio(np, DTS_FWDN_GPIO_STR, 0);
+	if ((!gpio_is_valid(nfc_gpio->dwl_req)))
+		pr_warn("%s: dwl_req gpio invalid %d\n", __func__,
+			nfc_gpio->dwl_req);
+
+	pr_info("%s: %d, %d, %d\n", __func__, nfc_gpio->irq, nfc_gpio->ven,
+		nfc_gpio->dwl_req);
+	return 0;
+}
+
+void set_valid_gpio(int gpio, int value)
+{
+	if (gpio_is_valid(gpio)) {
+		pr_debug("%s: gpio %d value %d\n", __func__, gpio, value);
+		gpio_set_value(gpio, value);
+		/* hardware dependent delay */
+		usleep_range(NFC_GPIO_SET_WAIT_TIME_US,
+			     NFC_GPIO_SET_WAIT_TIME_US + 100);
+	}
+}
+
+int get_valid_gpio(int gpio)
+{
+	int value = -EINVAL;
+
+	if (gpio_is_valid(gpio)) {
+		value = gpio_get_value(gpio);
+		pr_debug("%s: gpio %d value %d\n", __func__, gpio, value);
+	}
+	return value;
+}
+
+void gpio_set_ven(struct nfc_dev *nfc_dev, int value)
+{
+	struct platform_gpio *nfc_gpio = &nfc_dev->configs.gpio;
+
+	if (gpio_get_value(nfc_gpio->ven) != value) {
+		pr_debug("%s: value %d\n", __func__, value);
+
+		gpio_set_value(nfc_gpio->ven, value);
+		/* hardware dependent delay */
+		usleep_range(NFC_GPIO_SET_WAIT_TIME_US,
+			     NFC_GPIO_SET_WAIT_TIME_US + 100);
+	}
+}
+
+int configure_gpio(unsigned int gpio, int flag)
+{
+	int ret;
+
+	pr_debug("%s: nfc gpio [%d] flag [%01x]\n", __func__, gpio, flag);
+	if (gpio_is_valid(gpio)) {
+		ret = gpio_request(gpio, "nfc_gpio");
+		if (ret) {
+			pr_err("%s: unable to request nfc gpio [%d]\n",
+			       __func__, gpio);
+			return ret;
+		}
+		/* set direction and value for output pin */
+		if (flag & GPIO_OUTPUT) {
+			ret = gpio_direction_output(gpio, (GPIO_HIGH & flag));
+			pr_debug("%s: nfc o/p gpio %d level %d\n", __func__,
+				 gpio, gpio_get_value(gpio));
+		} else {
+			ret = gpio_direction_input(gpio);
+			pr_debug("%s: nfc i/p gpio %d\n", __func__, gpio);
+		}
+
+		if (ret) {
+			pr_err("%s: unable to set direction for nfc gpio [%d]\n",
+			       __func__, gpio);
+			gpio_free(gpio);
+			return ret;
+		}
+		/* Consider value as control for input IRQ pin */
+		if (flag & GPIO_IRQ) {
+			ret = gpio_to_irq(gpio);
+			if (ret < 0) {
+				pr_err("%s: unable to set irq [%d]\n", __func__,
+				       gpio);
+				gpio_free(gpio);
+				return ret;
+			}
+			pr_debug("%s: gpio_to_irq successful [%d]\n", __func__,
+				 gpio);
+			return ret;
+		}
+	} else {
+		pr_err("%s: invalid gpio\n", __func__);
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+void gpio_free_all(struct nfc_dev *nfc_dev)
+{
+	struct platform_gpio *nfc_gpio = &nfc_dev->configs.gpio;
+
+	if (gpio_is_valid(nfc_gpio->dwl_req))
+		gpio_free(nfc_gpio->dwl_req);
+
+	if (gpio_is_valid(nfc_gpio->irq))
+		gpio_free(nfc_gpio->irq);
+
+	if (gpio_is_valid(nfc_gpio->ven))
+		gpio_free(nfc_gpio->ven);
+}
+
+void nfc_misc_unregister(struct nfc_dev *nfc_dev, int count)
+{
+	pr_debug("%s: entry\n", __func__);
+	device_destroy(nfc_dev->nfc_class, nfc_dev->devno);
+	cdev_del(&nfc_dev->c_dev);
+	class_destroy(nfc_dev->nfc_class);
+	unregister_chrdev_region(nfc_dev->devno, count);
+}
+
+int nfc_misc_register(struct nfc_dev *nfc_dev,
+		      const struct file_operations *nfc_fops, int count,
+		      char *devname, char *classname)
+{
+	int ret = 0;
+
+	ret = alloc_chrdev_region(&nfc_dev->devno, 0, count, devname);
+	if (ret < 0) {
+		pr_err("%s: failed to alloc chrdev region ret %d\n", __func__,
+		       ret);
+		return ret;
+	}
+	nfc_dev->nfc_class = class_create(THIS_MODULE, classname);
+	if (IS_ERR(nfc_dev->nfc_class)) {
+		ret = PTR_ERR(nfc_dev->nfc_class);
+		pr_err("%s: failed to register device class ret %d\n", __func__,
+		       ret);
+		unregister_chrdev_region(nfc_dev->devno, count);
+		return ret;
+	}
+	cdev_init(&nfc_dev->c_dev, nfc_fops);
+	ret = cdev_add(&nfc_dev->c_dev, nfc_dev->devno, count);
+	if (ret < 0) {
+		pr_err("%s: failed to add cdev ret %d\n", __func__, ret);
+		class_destroy(nfc_dev->nfc_class);
+		unregister_chrdev_region(nfc_dev->devno, count);
+		return ret;
+	}
+	nfc_dev->nfc_device = device_create(nfc_dev->nfc_class, NULL,
+					    nfc_dev->devno, nfc_dev, devname);
+	if (IS_ERR(nfc_dev->nfc_device)) {
+		ret = PTR_ERR(nfc_dev->nfc_device);
+		pr_err("%s: failed to create the device ret %d\n", __func__,
+		       ret);
+		cdev_del(&nfc_dev->c_dev);
+		class_destroy(nfc_dev->nfc_class);
+		unregister_chrdev_region(nfc_dev->devno, count);
+		return ret;
+	}
+	return 0;
+}
+
+/**
+ * nfc_ioctl_power_states() - power control
+ * @nfc_dev:    nfc device data structure
+ * @arg:    mode that we want to move to
+ *
+ * Device power control. Depending on the arg value, device moves to
+ * different states, refer common.h for args
+ *
+ * Return: -ENOIOCTLCMD if arg is not supported, 0 in any other case
+ */
+static int nfc_ioctl_power_states(struct nfc_dev *nfc_dev, unsigned long arg)
+{
+	int ret = 0;
+	struct platform_gpio *nfc_gpio = &nfc_dev->configs.gpio;
+
+	if (arg == NFC_POWER_OFF) {
+		/*
+		 * We are attempting a hardware reset so let us disable
+		 * interrupts to avoid spurious notifications to upper
+		 * layers.
+		 */
+		nfc_dev->nfc_disable_intr(nfc_dev);
+		set_valid_gpio(nfc_gpio->dwl_req, 0);
+		gpio_set_ven(nfc_dev, 0);
+		nfc_dev->nfc_ven_enabled = false;
+	} else if (arg == NFC_POWER_ON) {
+		nfc_dev->nfc_enable_intr(nfc_dev);
+		set_valid_gpio(nfc_gpio->dwl_req, 0);
+
+		gpio_set_ven(nfc_dev, 1);
+		nfc_dev->nfc_ven_enabled = true;
+	} else if (arg == NFC_FW_DWL_VEN_TOGGLE) {
+		/*
+		 * We are switching to download Mode, toggle the enable pin
+		 * in order to set the NFCC in the new mode
+		 */
+		nfc_dev->nfc_disable_intr(nfc_dev);
+		set_valid_gpio(nfc_gpio->dwl_req, 1);
+		nfc_dev->nfc_state = NFC_STATE_FW_DWL;
+		gpio_set_ven(nfc_dev, 0);
+		gpio_set_ven(nfc_dev, 1);
+		nfc_dev->nfc_enable_intr(nfc_dev);
+	} else if (arg == NFC_FW_DWL_HIGH) {
+		/*
+		 * Setting firmware download gpio to HIGH
+		 * before FW download start
+		 */
+		set_valid_gpio(nfc_gpio->dwl_req, 1);
+		nfc_dev->nfc_state = NFC_STATE_FW_DWL;
+
+	} else if (arg == NFC_VEN_FORCED_HARD_RESET) {
+		nfc_dev->nfc_disable_intr(nfc_dev);
+		gpio_set_ven(nfc_dev, 0);
+		gpio_set_ven(nfc_dev, 1);
+		nfc_dev->nfc_enable_intr(nfc_dev);
+	} else if (arg == NFC_FW_DWL_LOW) {
+		/*
+		 * Setting firmware download gpio to LOW
+		 * FW download finished
+		 */
+		set_valid_gpio(nfc_gpio->dwl_req, 0);
+		nfc_dev->nfc_state = NFC_STATE_NCI;
+	} else {
+		pr_err("%s: bad arg %lu\n", __func__, arg);
+		ret = -ENOIOCTLCMD;
+	}
+	return ret;
+}
+
+/**
+ * nfc_dev_ioctl - used to set or get data from upper layer.
+ * @pfile   file node for opened device.
+ * @cmd     ioctl type from upper layer.
+ * @arg     ioctl arg from upper layer.
+ *
+ * NFC and ESE Device power control, based on the argument value
+ *
+ * Return: -ENOIOCTLCMD if arg is not supported, 0 or other in any other case
+ */
+long nfc_dev_ioctl(struct file *pfile, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct nfc_dev *nfc_dev = pfile->private_data;
+
+	if (!nfc_dev)
+		return -ENODEV;
+
+	pr_debug("%s: cmd = %x arg = %zx\n", __func__, cmd, arg);
+	if( cmd == NFC_SET_PWR ){
+		ret = nfc_ioctl_power_states(nfc_dev, arg);
+	} else {
+		pr_err("%s: bad cmd %lu\n", __func__, arg);
+		ret = -ENOIOCTLCMD;
+	}
+	return ret;
+}
+
+int nfc_dev_open(struct inode *inode, struct file *filp)
+{
+	struct nfc_dev *nfc_dev =
+		container_of(inode->i_cdev, struct nfc_dev, c_dev);
+
+	pr_debug("%s: %d, %d\n", __func__, imajor(inode), iminor(inode));
+
+	mutex_lock(&nfc_dev->dev_ref_mutex);
+
+	filp->private_data = nfc_dev;
+
+	if (nfc_dev->dev_ref_count == 0) {
+		set_valid_gpio(nfc_dev->configs.gpio.dwl_req, 0);
+
+		nfc_dev->nfc_enable_intr(nfc_dev);
+	}
+	nfc_dev->dev_ref_count = nfc_dev->dev_ref_count + 1;
+	mutex_unlock(&nfc_dev->dev_ref_mutex);
+	return 0;
+}
+
+int nfc_dev_close(struct inode *inode, struct file *filp)
+{
+	struct nfc_dev *nfc_dev =
+		container_of(inode->i_cdev, struct nfc_dev, c_dev);
+
+	pr_debug("%s: %d, %d\n", __func__, imajor(inode), iminor(inode));
+	mutex_lock(&nfc_dev->dev_ref_mutex);
+	if (nfc_dev->dev_ref_count == 1) {
+		nfc_dev->nfc_disable_intr(nfc_dev);
+		set_valid_gpio(nfc_dev->configs.gpio.dwl_req, 0);
+	}
+	if (nfc_dev->dev_ref_count > 0)
+		nfc_dev->dev_ref_count = nfc_dev->dev_ref_count - 1;
+	filp->private_data = NULL;
+
+	mutex_unlock(&nfc_dev->dev_ref_mutex);
+	return 0;
+}
+
+int validate_nfc_state_nci(struct nfc_dev *nfc_dev)
+{
+	struct platform_gpio *nfc_gpio = &nfc_dev->configs.gpio;
+
+	if (!gpio_get_value(nfc_gpio->ven)) {
+		pr_err("%s: ven low - nfcc powered off\n", __func__);
+		return -ENODEV;
+	}
+	if (get_valid_gpio(nfc_gpio->dwl_req) == 1) {
+		pr_err("%s: fw download in-progress\n", __func__);
+		return -EBUSY;
+	}
+	if (nfc_dev->nfc_state != NFC_STATE_NCI) {
+		pr_err("%s: fw download state\n", __func__);
+		return -EBUSY;
+	}
+	return 0;
+}
diff --git a/drivers/misc/nxp-pn7160/nfc/common.h b/drivers/misc/nxp-pn7160/nfc/common.h
new file mode 100755
index 000000000000..678177b16cc0
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/nfc/common.h
@@ -0,0 +1,208 @@
+/******************************************************************************
+ * Copyright (C) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2019-2021 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ******************************************************************************/
+#ifndef _COMMON_H_
+#define _COMMON_H_
+
+#include <linux/cdev.h>
+
+#if IS_ENABLED(CONFIG_NXP_NFC_I2C)
+#include "i2c_drv.h"
+#endif //IS_ENABLED(CONFIG_NXP_NFC_I2C)
+
+#if IS_ENABLED(CONFIG_NXP_NFC_SPI)
+#include "spi_drv.h"
+#endif //IS_ENABLED(CONFIG_NXP_NFC_SPI)
+
+/* Max device count for this driver */
+#define DEV_COUNT			1
+/* i2c device class */
+#define CLASS_NAME			"nfc"
+
+/* NFC character device name, this will be in /dev/ */
+#define NFC_CHAR_DEV_NAME		"nxpnfc"
+
+/* NCI packet details */
+#define NCI_CMD				(0x20)
+#define NCI_RSP				(0x40)
+#define NCI_HDR_LEN			(3)
+#define NCI_HDR_IDX			(0)
+#define NCI_HDR_OID_IDX			(1)
+#define NCI_PAYLOAD_IDX			(3)
+#define NCI_PAYLOAD_LEN_IDX		(2)
+
+/* FW DNLD packet details */
+#define DL_HDR_LEN			(2)
+#define DL_CRC_LEN			(2)
+
+#define MAX_NCI_PAYLOAD_LEN		(255)
+#define MAX_NCI_BUFFER_SIZE		(NCI_HDR_LEN + MAX_NCI_PAYLOAD_LEN)
+#define MAX_DL_PAYLOAD_LEN		(550)
+#define MAX_DL_BUFFER_SIZE		(DL_HDR_LEN + DL_CRC_LEN + \
+					MAX_DL_PAYLOAD_LEN)
+
+
+/* Retry count for normal write */
+#define NO_RETRY			(1)
+/* Maximum retry count for standby writes */
+#define MAX_RETRY_COUNT			(3)
+#define MAX_WRITE_IRQ_COUNT		(5)
+#define MAX_IRQ_WAIT_TIME		(90)
+#define WAKEUP_SRC_TIMEOUT		(2000)
+
+/* command response timeout */
+#define NCI_CMD_RSP_TIMEOUT_MS		(2000)
+/* Time to wait for NFCC to be ready again after any change in the GPIO */
+#define NFC_GPIO_SET_WAIT_TIME_US	(10000)
+/* Time to wait for IRQ low during write 5*3ms */
+#define NFC_WRITE_IRQ_WAIT_TIME_US	(3000)
+/* Time to wait before retrying i2c/I3C writes */
+#define WRITE_RETRY_WAIT_TIME_US	(1000)
+/* Time to wait before retrying read for some specific usecases */
+#define READ_RETRY_WAIT_TIME_US		(3500)
+#define NFC_MAGIC			(0xE9)
+
+/* Ioctls */
+/* The type should be aligned with MW HAL definitions */
+#define NFC_SET_PWR			_IOW(NFC_MAGIC, 0x01, long)
+#define ESE_SET_PWR			_IOW(NFC_MAGIC, 0x02, long)
+#define ESE_GET_PWR			_IOR(NFC_MAGIC, 0x03, long)
+
+#define DTS_IRQ_GPIO_STR		"nxp,nxpnfc-irq"
+#define DTS_VEN_GPIO_STR		"nxp,nxpnfc-ven"
+#define DTS_FWDN_GPIO_STR		"nxp,nxpnfc-fw-dwnld"
+
+enum nfcc_ioctl_request {
+	/* NFC disable request with VEN LOW */
+	NFC_POWER_OFF = 0,
+	/* NFC enable request with VEN Toggle */
+	NFC_POWER_ON,
+	/* firmware download request with VEN Toggle */
+	NFC_FW_DWL_VEN_TOGGLE,
+	/* ISO reset request */
+	NFC_ISO_RESET,
+	/* request for firmware download gpio HIGH */
+	NFC_FW_DWL_HIGH,
+	/* VEN hard reset request */
+	NFC_VEN_FORCED_HARD_RESET,
+	/* request for firmware download gpio LOW */
+	NFC_FW_DWL_LOW,
+};
+
+/* nfc platform interface type */
+enum interface_flags {
+	/* I2C physical IF for NFCC */
+	PLATFORM_IF_I2C = 0,
+	PLATFORM_IF_SPI = 1,
+};
+
+/* nfc state flags */
+enum nfc_state_flags {
+	/* nfc in unknown state */
+	NFC_STATE_UNKNOWN = 0,
+	/* nfc in download mode */
+	NFC_STATE_FW_DWL = 0x1,
+	/* nfc booted in NCI mode */
+	NFC_STATE_NCI = 0x2,
+	/* nfc booted in Fw teared mode */
+	NFC_STATE_FW_TEARED = 0x4,
+};
+/*
+ * Power state for IBI handing, mainly needed to defer the IBI handling
+ *  for the IBI received in suspend state to do it later in resume call
+ */
+enum pm_state_flags {
+	PM_STATE_NORMAL = 0,
+	PM_STATE_SUSPEND,
+	PM_STATE_IBI_BEFORE_RESUME,
+};
+
+/* Enum for GPIO values */
+enum gpio_values {
+	GPIO_INPUT = 0x0,
+	GPIO_OUTPUT = 0x1,
+	GPIO_HIGH = 0x2,
+	GPIO_OUTPUT_HIGH = 0x3,
+	GPIO_IRQ = 0x4,
+};
+
+/* NFC GPIO variables */
+struct platform_gpio {
+	unsigned int irq;
+	unsigned int ven;
+	unsigned int dwl_req;
+};
+
+/* NFC Struct to get all the required configs from DTS */
+struct platform_configs {
+	struct platform_gpio gpio;
+};
+
+/* Device specific structure */
+struct nfc_dev {
+	wait_queue_head_t read_wq;
+	struct mutex read_mutex;
+	struct mutex write_mutex;
+	uint8_t *read_kbuf;
+	uint8_t *write_kbuf;
+	struct mutex dev_ref_mutex;
+	unsigned int dev_ref_count;
+	struct class *nfc_class;
+	struct device *nfc_device;
+	struct cdev c_dev;
+	dev_t devno;
+	/* Interface flag */
+	uint8_t interface;
+	/* nfc state flags */
+	uint8_t nfc_state;
+	/* NFC VEN pin state */
+	bool nfc_ven_enabled;
+	union {
+	#if IS_ENABLED(CONFIG_NXP_NFC_I2C)
+		struct i2c_dev i2c_dev;
+	#endif //IS_ENABLED(CONFIG_NXP_NFC_I2C)
+	#if IS_ENABLED(CONFIG_NXP_NFC_SPI)
+		struct spi_dev spi_dev;
+	#endif //IS_ENABLED(CONFIG_NXP_NFC_SPI)
+	};
+	struct platform_configs configs;
+
+	/* function pointers for the common i2c functionality */
+	int (*nfc_read)(struct nfc_dev *dev, char *buf, size_t count,
+			int timeout);
+	int (*nfc_write)(struct nfc_dev *dev, const char *buf,
+			 const size_t count, int max_retry_cnt);
+	int (*nfc_enable_intr)(struct nfc_dev *dev);
+	int (*nfc_disable_intr)(struct nfc_dev *dev);
+};
+
+int nfc_dev_open(struct inode *inode, struct file *filp);
+int nfc_dev_close(struct inode *inode, struct file *filp);
+long nfc_dev_ioctl(struct file *pfile, unsigned int cmd, unsigned long arg);
+int nfc_parse_dt(struct device *dev, struct platform_configs *nfc_configs,
+		 uint8_t interface);
+int nfc_misc_register(struct nfc_dev *nfc_dev,
+		      const struct file_operations *nfc_fops, int count,
+		      char *devname, char *classname);
+void nfc_misc_unregister(struct nfc_dev *nfc_dev, int count);
+int configure_gpio(unsigned int gpio, int flag);
+void gpio_set_ven(struct nfc_dev *nfc_dev, int value);
+void gpio_free_all(struct nfc_dev *nfc_dev);
+int validate_nfc_state_nci(struct nfc_dev *nfc_dev);
+#endif /* _COMMON_H_ */
diff --git a/drivers/misc/nxp-pn7160/nfc/i2c_drv.c b/drivers/misc/nxp-pn7160/nfc/i2c_drv.c
new file mode 100755
index 000000000000..716247e63d8f
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/nfc/i2c_drv.c
@@ -0,0 +1,488 @@
+/******************************************************************************
+ * Copyright (C) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2013-2021 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ******************************************************************************/
+/*
+ * Copyright (C) 2010 Trusted Logic S.A.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+
+#include "common.h"
+
+/**
+ * i2c_disable_irq()
+ *
+ * Check if interrupt is disabled or not
+ * and disable interrupt
+ *
+ * Return: int
+ */
+int i2c_disable_irq(struct nfc_dev *dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->i2c_dev.irq_enabled_lock, flags);
+	if (dev->i2c_dev.irq_enabled) {
+		disable_irq_nosync(dev->i2c_dev.client->irq);
+		dev->i2c_dev.irq_enabled = false;
+	}
+	spin_unlock_irqrestore(&dev->i2c_dev.irq_enabled_lock, flags);
+
+	return 0;
+}
+
+/**
+ * i2c_enable_irq()
+ *
+ * Check if interrupt is enabled or not
+ * and enable interrupt
+ *
+ * Return: int
+ */
+int i2c_enable_irq(struct nfc_dev *dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->i2c_dev.irq_enabled_lock, flags);
+	if (!dev->i2c_dev.irq_enabled) {
+		dev->i2c_dev.irq_enabled = true;
+		enable_irq(dev->i2c_dev.client->irq);
+	}
+	spin_unlock_irqrestore(&dev->i2c_dev.irq_enabled_lock, flags);
+
+	return 0;
+}
+
+static irqreturn_t i2c_irq_handler(int irq, void *dev_id)
+{
+	struct nfc_dev *nfc_dev = dev_id;
+	struct i2c_dev *i2c_dev = &nfc_dev->i2c_dev;
+
+	if (device_may_wakeup(&i2c_dev->client->dev))
+		pm_wakeup_event(&i2c_dev->client->dev, WAKEUP_SRC_TIMEOUT);
+
+	i2c_disable_irq(nfc_dev);
+	wake_up(&nfc_dev->read_wq);
+
+	return IRQ_HANDLED;
+}
+
+int i2c_read(struct nfc_dev *nfc_dev, char *buf, size_t count, int timeout)
+{
+	int ret;
+	struct i2c_dev *i2c_dev = &nfc_dev->i2c_dev;
+	struct platform_gpio *nfc_gpio = &nfc_dev->configs.gpio;
+
+	pr_debug("%s: reading %zu bytes.\n", __func__, count);
+
+	if (timeout > NCI_CMD_RSP_TIMEOUT_MS)
+		timeout = NCI_CMD_RSP_TIMEOUT_MS;
+
+	if (count > MAX_NCI_BUFFER_SIZE)
+		count = MAX_NCI_BUFFER_SIZE;
+
+	if (!gpio_get_value(nfc_gpio->irq)) {
+		while (1) {
+			ret = 0;
+			if (!i2c_dev->irq_enabled) {
+				i2c_dev->irq_enabled = true;
+				enable_irq(i2c_dev->client->irq);
+			}
+			if (!gpio_get_value(nfc_gpio->irq)) {
+				if (timeout) {
+					ret = wait_event_interruptible_timeout(
+						nfc_dev->read_wq,
+						!i2c_dev->irq_enabled,
+						msecs_to_jiffies(timeout));
+
+					if (ret <= 0) {
+						pr_err("%s: timeout error\n",
+						       __func__);
+						goto err;
+					}
+				} else {
+					ret = wait_event_interruptible(
+						nfc_dev->read_wq,
+						!i2c_dev->irq_enabled);
+					if (ret) {
+						pr_err("%s: err wakeup of wq\n",
+						       __func__);
+						goto err;
+					}
+				}
+			}
+			i2c_disable_irq(nfc_dev);
+
+			if (gpio_get_value(nfc_gpio->irq))
+				break;
+			if (!gpio_get_value(nfc_gpio->ven)) {
+				pr_info("%s: releasing read\n", __func__);
+				ret = -EIO;
+				goto err;
+			}
+			pr_warn("%s: spurious interrupt detected\n", __func__);
+		}
+	}
+
+	memset(buf, 0x00, count);
+	/* Read data */
+	ret = i2c_master_recv(nfc_dev->i2c_dev.client, buf, count);
+	if (ret <= 0) {
+		pr_err("%s: returned %d\n", __func__, ret);
+		goto err;
+	}
+err:
+	return ret;
+}
+
+int i2c_write(struct nfc_dev *nfc_dev, const char *buf, size_t count,
+	      int max_retry_cnt)
+{
+	int ret = -EINVAL;
+	int retry_cnt;
+	struct platform_gpio *nfc_gpio = &nfc_dev->configs.gpio;
+
+	if (count > MAX_DL_BUFFER_SIZE)
+		count = MAX_DL_BUFFER_SIZE;
+
+	pr_debug("%s: writing %zu bytes.\n", __func__, count);
+	/*
+	 * Wait for any pending read for max 15ms before write
+	 * This is to avoid any packet corruption during read, when
+	 * the host cmds resets NFCC during any parallel read operation
+	 */
+	for (retry_cnt = 1; retry_cnt <= MAX_WRITE_IRQ_COUNT; retry_cnt++) {
+		if (gpio_get_value(nfc_gpio->irq)) {
+			pr_warn("%s: irq high during write, wait\n", __func__);
+			usleep_range(NFC_WRITE_IRQ_WAIT_TIME_US,
+				     NFC_WRITE_IRQ_WAIT_TIME_US + 100);
+		} else {
+			break;
+		}
+		if (retry_cnt == MAX_WRITE_IRQ_COUNT &&
+			     gpio_get_value(nfc_gpio->irq)) {
+			pr_warn("%s: allow after maximum wait\n", __func__);
+		}
+	}
+
+	for (retry_cnt = 1; retry_cnt <= max_retry_cnt; retry_cnt++) {
+		ret = i2c_master_send(nfc_dev->i2c_dev.client, buf, count);
+		if (ret <= 0) {
+			pr_warn("%s: write failed ret(%d), maybe in standby\n",
+				__func__, ret);
+			usleep_range(WRITE_RETRY_WAIT_TIME_US,
+				     WRITE_RETRY_WAIT_TIME_US + 100);
+		} else if (ret != count) {
+			pr_err("%s: failed to write %d\n", __func__, ret);
+			ret = -EIO;
+		} else if (ret == count)
+			break;
+	}
+	return ret;
+}
+
+ssize_t nfc_i2c_dev_read(struct file *filp, char __user *buf, size_t count,
+			 loff_t *offset)
+{
+	int ret;
+	struct nfc_dev *nfc_dev = (struct nfc_dev *)filp->private_data;
+
+	if (filp->f_flags & O_NONBLOCK) {
+		pr_err("%s: f_flags has nonblock. try again\n", __func__);
+		return -EAGAIN;
+	}
+	mutex_lock(&nfc_dev->read_mutex);
+	ret = i2c_read(nfc_dev, nfc_dev->read_kbuf, count, 0);
+	if (ret > 0) {
+		if (copy_to_user(buf, nfc_dev->read_kbuf, ret)) {
+			pr_warn("%s: failed to copy to user space\n", __func__);
+			ret = -EFAULT;
+		}
+	}
+	mutex_unlock(&nfc_dev->read_mutex);
+	return ret;
+}
+
+ssize_t nfc_i2c_dev_write(struct file *filp, const char __user *buf,
+			  size_t count, loff_t *offset)
+{
+	int ret;
+	struct nfc_dev *nfc_dev = (struct nfc_dev *)filp->private_data;
+
+	if (count > MAX_DL_BUFFER_SIZE)
+		count = MAX_DL_BUFFER_SIZE;
+
+	mutex_lock(&nfc_dev->write_mutex);
+	if (copy_from_user(nfc_dev->write_kbuf, buf, count)) {
+		pr_err("%s: failed to copy from user space\n", __func__);
+		mutex_unlock(&nfc_dev->write_mutex);
+		return -EFAULT;
+	}
+	ret = i2c_write(nfc_dev, nfc_dev->write_kbuf, count, NO_RETRY);
+	mutex_unlock(&nfc_dev->write_mutex);
+	return ret;
+}
+
+static const struct file_operations nfc_i2c_dev_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.read = nfc_i2c_dev_read,
+	.write = nfc_i2c_dev_write,
+	.open = nfc_dev_open,
+	.release = nfc_dev_close,
+	.unlocked_ioctl = nfc_dev_ioctl,
+};
+
+int nfc_i2c_dev_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret = 0;
+	struct nfc_dev *nfc_dev = NULL;
+	struct i2c_dev *i2c_dev = NULL;
+	struct platform_configs nfc_configs;
+	struct platform_gpio *nfc_gpio = &nfc_configs.gpio;
+
+	pr_debug("%s: enter\n", __func__);
+	/* retrieve details of gpios from dt */
+	ret = nfc_parse_dt(&client->dev, &nfc_configs, PLATFORM_IF_I2C);
+	if (ret) {
+		pr_err("%s: failed to parse dt\n", __func__);
+		goto err;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("%s: need I2C_FUNC_I2C\n", __func__);
+		ret = -ENODEV;
+		goto err;
+	}
+	nfc_dev = kzalloc(sizeof(struct nfc_dev), GFP_KERNEL);
+	if (nfc_dev == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+	nfc_dev->read_kbuf = kzalloc(MAX_NCI_BUFFER_SIZE, GFP_DMA | GFP_KERNEL);
+	if (!nfc_dev->read_kbuf) {
+		ret = -ENOMEM;
+		goto err_free_nfc_dev;
+	}
+	nfc_dev->write_kbuf = kzalloc(MAX_DL_BUFFER_SIZE, GFP_DMA | GFP_KERNEL);
+	if (!nfc_dev->write_kbuf) {
+		ret = -ENOMEM;
+		goto err_free_read_kbuf;
+	}
+	nfc_dev->interface = PLATFORM_IF_I2C;
+	nfc_dev->nfc_state = NFC_STATE_NCI;
+	nfc_dev->i2c_dev.client = client;
+	i2c_dev = &nfc_dev->i2c_dev;
+	nfc_dev->nfc_read = i2c_read;
+	nfc_dev->nfc_write = i2c_write;
+	nfc_dev->nfc_enable_intr = i2c_enable_irq;
+	nfc_dev->nfc_disable_intr = i2c_disable_irq;
+	ret = configure_gpio(nfc_gpio->ven, GPIO_OUTPUT);
+	if (ret) {
+		pr_err("%s: unable to request nfc reset gpio [%d]\n", __func__,
+		       nfc_gpio->ven);
+		goto err_free_write_kbuf;
+	}
+	ret = configure_gpio(nfc_gpio->irq, GPIO_IRQ);
+	if (ret <= 0) {
+		pr_err("%s: unable to request nfc irq gpio [%d]\n", __func__,
+		       nfc_gpio->irq);
+		goto err_free_gpio;
+	}
+	client->irq = ret;
+	ret = configure_gpio(nfc_gpio->dwl_req, GPIO_OUTPUT);
+	if (ret) {
+		pr_err("%s: unable to request nfc firm downl gpio [%d]\n",
+		       __func__, nfc_gpio->dwl_req);
+	}
+
+	/* copy the retrieved gpio details from DT */
+	memcpy(&nfc_dev->configs, &nfc_configs,
+	       sizeof(struct platform_configs));
+
+	/* init mutex and queues */
+	init_waitqueue_head(&nfc_dev->read_wq);
+	mutex_init(&nfc_dev->read_mutex);
+	mutex_init(&nfc_dev->write_mutex);
+	mutex_init(&nfc_dev->dev_ref_mutex);
+	spin_lock_init(&i2c_dev->irq_enabled_lock);
+	ret = nfc_misc_register(nfc_dev, &nfc_i2c_dev_fops, DEV_COUNT,
+				NFC_CHAR_DEV_NAME, CLASS_NAME);
+	if (ret) {
+		pr_err("%s: nfc_misc_register failed\n", __func__);
+		goto err_mutex_destroy;
+	}
+	/* interrupt initializations */
+	pr_info("%s: requesting IRQ %d\n", __func__, client->irq);
+	i2c_dev->irq_enabled = true;
+	ret = request_irq(client->irq, i2c_irq_handler, IRQF_TRIGGER_HIGH,
+			  client->name, nfc_dev);
+	if (ret) {
+		pr_err("%s: request_irq failed\n", __func__);
+		goto err_nfc_misc_unregister;
+	}
+	i2c_disable_irq(nfc_dev);
+	gpio_set_ven(nfc_dev, 1);
+	gpio_set_ven(nfc_dev, 0);
+	gpio_set_ven(nfc_dev, 1);
+	device_init_wakeup(&client->dev, true);
+	i2c_set_clientdata(client, nfc_dev);
+	i2c_dev->irq_wake_up = false;
+
+	pr_info("%s: probing nfc i2c successfully\n", __func__);
+	return 0;
+err_nfc_misc_unregister:
+	nfc_misc_unregister(nfc_dev, DEV_COUNT);
+err_mutex_destroy:
+	mutex_destroy(&nfc_dev->dev_ref_mutex);
+	mutex_destroy(&nfc_dev->read_mutex);
+	mutex_destroy(&nfc_dev->write_mutex);
+err_free_gpio:
+	gpio_free_all(nfc_dev);
+err_free_write_kbuf:
+	kfree(nfc_dev->write_kbuf);
+err_free_read_kbuf:
+	kfree(nfc_dev->read_kbuf);
+err_free_nfc_dev:
+	kfree(nfc_dev);
+err:
+	pr_err("%s: probing not successful, check hardware\n", __func__);
+	return ret;
+}
+
+void nfc_i2c_dev_remove(struct i2c_client *client)
+{
+	struct nfc_dev *nfc_dev = NULL;
+
+	pr_info("%s: remove device\n", __func__);
+	nfc_dev = i2c_get_clientdata(client);
+	if (!nfc_dev) {
+		pr_err("%s: device doesn't exist anymore\n", __func__);
+		return ;
+	}
+	if (nfc_dev->dev_ref_count > 0) {
+		pr_err("%s: device already in use\n", __func__);
+		return ;
+	}
+	device_init_wakeup(&client->dev, false);
+	free_irq(client->irq, nfc_dev);
+	nfc_misc_unregister(nfc_dev, DEV_COUNT);
+	mutex_destroy(&nfc_dev->read_mutex);
+	mutex_destroy(&nfc_dev->write_mutex);
+	gpio_free_all(nfc_dev);
+	kfree(nfc_dev->read_kbuf);
+	kfree(nfc_dev->write_kbuf);
+	kfree(nfc_dev);
+	return ;
+}
+
+int nfc_i2c_dev_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct nfc_dev *nfc_dev = i2c_get_clientdata(client);
+	struct i2c_dev *i2c_dev = &nfc_dev->i2c_dev;
+
+	if (device_may_wakeup(&client->dev) && i2c_dev->irq_enabled) {
+		if (!enable_irq_wake(client->irq))
+			i2c_dev->irq_wake_up = true;
+	}
+	return 0;
+}
+
+int nfc_i2c_dev_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct nfc_dev *nfc_dev = i2c_get_clientdata(client);
+	struct i2c_dev *i2c_dev = &nfc_dev->i2c_dev;
+
+	if (device_may_wakeup(&client->dev) && i2c_dev->irq_wake_up) {
+		if (!disable_irq_wake(client->irq))
+			i2c_dev->irq_wake_up = false;
+	}
+	return 0;
+}
+
+static const struct i2c_device_id nfc_i2c_dev_id[] = { { NFC_I2C_DEV_ID, 0 },
+						       {} };
+
+static const struct of_device_id nfc_i2c_dev_match_table[] = {
+	{
+		.compatible = NFC_I2C_DRV_STR,
+	},
+	{}
+};
+
+static const struct dev_pm_ops nfc_i2c_dev_pm_ops = { SET_SYSTEM_SLEEP_PM_OPS(
+	nfc_i2c_dev_suspend, nfc_i2c_dev_resume) };
+
+static struct i2c_driver nfc_i2c_dev_driver = {
+	.id_table = nfc_i2c_dev_id,
+	.probe = nfc_i2c_dev_probe,
+	.remove = nfc_i2c_dev_remove,
+	.driver = {
+		.name = NFC_I2C_DRV_STR,
+		.pm = &nfc_i2c_dev_pm_ops,
+		.of_match_table = nfc_i2c_dev_match_table,
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+	},
+};
+
+MODULE_DEVICE_TABLE(of, nfc_i2c_dev_match_table);
+
+static int __init nfc_i2c_dev_init(void)
+{
+	int ret = 0;
+
+	pr_info("%s: Loading NXP NFC I2C driver\n", __func__);
+	ret = i2c_add_driver(&nfc_i2c_dev_driver);
+	if (ret != 0)
+		pr_err("%s: NFC I2C add driver error ret %d\n", __func__, ret);
+	return ret;
+}
+
+module_init(nfc_i2c_dev_init);
+
+static void __exit nfc_i2c_dev_exit(void)
+{
+	pr_info("%s: Unloading NXP NFC I2C driver\n", __func__);
+	i2c_del_driver(&nfc_i2c_dev_driver);
+}
+
+module_exit(nfc_i2c_dev_exit);
+
+MODULE_DESCRIPTION("NXP NFC I2C driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/nxp-pn7160/nfc/i2c_drv.h b/drivers/misc/nxp-pn7160/nfc/i2c_drv.h
new file mode 100755
index 000000000000..6221e2b0388a
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/nfc/i2c_drv.h
@@ -0,0 +1,46 @@
+/******************************************************************************
+ * Copyright (C) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2019-2021 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ******************************************************************************/
+#ifndef _I2C_DRV_H_
+#define _I2C_DRV_H_
+
+#include <linux/i2c.h>
+
+/* kept same as dts */
+#define NFC_I2C_DRV_STR			"nxp,nxpnfc"
+#define NFC_I2C_DEV_ID			"nxpnfc"
+
+/* Interface specific parameters */
+struct i2c_dev {
+	struct i2c_client *client;
+	/* IRQ parameters */
+	bool irq_enabled;
+	spinlock_t irq_enabled_lock;
+	/* NFC_IRQ wake-up state */
+	bool irq_wake_up;
+};
+
+long nfc_i2c_dev_ioctl(struct file *pfile, unsigned int cmd, unsigned long arg);
+int nfc_i2c_dev_probe(struct i2c_client *client,
+		      const struct i2c_device_id *id);
+void nfc_i2c_dev_remove(struct i2c_client *client);
+int nfc_i2c_dev_suspend(struct device *device);
+int nfc_i2c_dev_resume(struct device *device);
+
+#endif /* _I2C_DRV_H_ */
diff --git a/drivers/misc/nxp-pn7160/nfc/spi_drv.c b/drivers/misc/nxp-pn7160/nfc/spi_drv.c
new file mode 100755
index 000000000000..ebebfffbbcac
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/nfc/spi_drv.c
@@ -0,0 +1,586 @@
+/******************************************************************************
+ * Copyright (C) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2013-2021 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ******************************************************************************/
+/*
+ * Copyright (C) 2010 Trusted Logic S.A.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+
+#include "common.h"
+
+/**
+ * spi_disable_irq()
+ *
+ * Check if interrupt is disabled or not
+ * and disable interrupt
+ *
+ * Return: int
+ */
+int spi_disable_irq(struct nfc_dev *dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->spi_dev.irq_enabled_lock, flags);
+	if (dev->spi_dev.irq_enabled) {
+		disable_irq_nosync(dev->spi_dev.client->irq);
+		dev->spi_dev.irq_enabled = false;
+	}
+	spin_unlock_irqrestore(&dev->spi_dev.irq_enabled_lock, flags);
+
+	return 0;
+}
+
+/**
+ * spi_enable_irq()
+ *
+ * Check if interrupt is enabled or not
+ * and enable interrupt
+ *
+ * Return: int
+ */
+int spi_enable_irq(struct nfc_dev *dev)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->spi_dev.irq_enabled_lock, flags);
+	if (!dev->spi_dev.irq_enabled) {
+		dev->spi_dev.irq_enabled = true;
+		enable_irq(dev->spi_dev.client->irq);
+	}
+	spin_unlock_irqrestore(&dev->spi_dev.irq_enabled_lock, flags);
+	return 0;
+}
+
+/**
+ * add_spi_write_prefix() - Adds Write Prefix to the Buffer
+ * @cmd: Takes uint8_t* buffer as an input
+ *
+ * Function to add prefix 0x7F to the write buffer
+ *
+ * Return: uint8_t* buffer
+ */
+uint8_t *add_spi_write_prefix(uint8_t *cmd)
+{
+	*cmd++ = WRITE_PREFIX_ON_WRITE;
+	return cmd;
+}
+
+/**
+ * add_write_prefix_for_spi_read() - Adds Write Prefix to the Buffer for spi read
+ * @cmd: Takes uint8_t* buffer as an input
+ *
+ * Function to add prefix 0xFF to the write buffer
+ *
+ * Return: uint8_t* buffer
+ */
+uint8_t *add_write_prefix_for_spi_read(uint8_t *cmd)
+{
+	*cmd++ = WRITE_PREFIX_ON_READ;
+	return cmd;
+}
+
+/**
+ * get_spi_command_length() - Adds Write Prefix to the Buffer
+ * @actual_length: Takes integer value as actual command length
+ *
+ * Function adds prefix to the command length
+ *
+ * Return: integer value by adding prefix length to actual command length
+ */
+int get_spi_command_length(int actual_length)
+{
+	return actual_length + PREFIX_LENGTH;
+}
+
+static irqreturn_t spi_irq_handler(int irq, void *dev_id)
+{
+	struct nfc_dev *nfc_dev = dev_id;
+	struct spi_dev *spi_dev = &nfc_dev->spi_dev;
+
+	if (device_may_wakeup(&spi_dev->client->dev))
+		pm_wakeup_event(&spi_dev->client->dev, WAKEUP_SRC_TIMEOUT);
+
+	spi_disable_irq(nfc_dev);
+	wake_up(&nfc_dev->read_wq);
+
+	return IRQ_HANDLED;
+}
+
+int nfc_spi_read(struct nfc_dev *nfc_dev, char *buf, size_t count, int timeout)
+{
+	int ret;
+	int cmd_length = 0;
+	struct spi_dev *spi_dev = &nfc_dev->spi_dev;
+	struct platform_gpio *nfc_gpio = &nfc_dev->configs.gpio;
+
+	pr_debug("%s: reading %zu bytes.\n", __func__, count);
+
+	if (timeout > NCI_CMD_RSP_TIMEOUT_MS)
+		timeout = NCI_CMD_RSP_TIMEOUT_MS;
+
+	if (count > MAX_NCI_BUFFER_SIZE)
+		count = MAX_NCI_BUFFER_SIZE;
+
+	if (!gpio_get_value(nfc_gpio->irq)) {
+		while (1) {
+			ret = 0;
+			if (!spi_dev->irq_enabled) {
+				spi_dev->irq_enabled = true;
+				enable_irq(spi_dev->client->irq);
+			}
+			if (!gpio_get_value(nfc_gpio->irq)) {
+				if (timeout) {
+					ret = wait_event_interruptible_timeout(
+						nfc_dev->read_wq,
+						!spi_dev->irq_enabled,
+						msecs_to_jiffies(timeout));
+
+					if (ret <= 0) {
+						pr_err("%s: timeout error\n",
+						       __func__);
+						goto err;
+					}
+				} else {
+					ret = wait_event_interruptible(
+						nfc_dev->read_wq,
+						!spi_dev->irq_enabled);
+					if (ret) {
+						pr_err("%s: err wakeup of wq\n",
+						       __func__);
+						goto err;
+					}
+				}
+			}
+			spi_disable_irq(nfc_dev);
+
+			if (gpio_get_value(nfc_gpio->irq))
+				break;
+			if (!gpio_get_value(nfc_gpio->ven)) {
+				pr_info("%s: releasing read\n", __func__);
+				ret = -EIO;
+				goto err;
+			}
+			pr_warn("%s: spurious interrupt detected\n", __func__);
+		}
+	}
+
+	add_write_prefix_for_spi_read(spi_dev->tmp_write_kbuf);
+	memset(buf, 0x00, count);
+	/* Read data */
+	ret = spi_write_then_read(
+		spi_dev->client,
+		spi_dev->tmp_write_kbuf,
+		PREFIX_LENGTH, buf, count);
+	if (ret < 0) {
+		pr_err("%s: returned %d\n", __func__, ret);
+		goto err;
+	}
+	return count;
+err:
+	return ret;
+}
+
+int nfc_spi_write(struct nfc_dev *nfc_dev, const char *buf, size_t count,
+	       int max_retry_cnt)
+{
+	int ret = -EINVAL;
+	int retry_cnt;
+	struct platform_gpio *nfc_gpio = &nfc_dev->configs.gpio;
+
+	if (count <= 0)
+		return ret;
+
+	if (count > MAX_DL_BUFFER_SIZE + PREFIX_LENGTH)
+		count = MAX_DL_BUFFER_SIZE + PREFIX_LENGTH;
+
+	pr_debug("%s: writing %zu bytes.\n", __func__, count);
+	/*
+	 * Wait for any pending read for max 15ms before write
+	 * This is to avoid any packet corruption during read, when
+	 * the host cmds resets NFCC during any parallel read operation
+	 */
+	for (retry_cnt = 1; retry_cnt <= MAX_WRITE_IRQ_COUNT; retry_cnt++) {
+		if (gpio_get_value(nfc_gpio->irq)) {
+			pr_warn("%s: irq high during write, wait\n", __func__);
+			usleep_range(NFC_WRITE_IRQ_WAIT_TIME_US,
+				     NFC_WRITE_IRQ_WAIT_TIME_US + 100);
+		} else {
+			break;
+		}
+		if (retry_cnt == MAX_WRITE_IRQ_COUNT &&
+			     gpio_get_value(nfc_gpio->irq)) {
+			pr_warn("%s: allow after maximum wait\n", __func__);
+		}
+	}
+	for (retry_cnt = 1; retry_cnt <= max_retry_cnt; retry_cnt++) {
+		struct spi_transfer transfer = {
+			.tx_buf = buf,
+			.rx_buf = nfc_dev->spi_dev.tmp_read_kbuf,
+			.len = count,
+		};
+		struct spi_message message;
+
+		spi_message_init(&message);
+		spi_message_add_tail(&transfer, &message);
+		ret = spi_sync(nfc_dev->spi_dev.client, &message);
+
+		// Checking for the first read byte is 0xFF
+		if ((nfc_dev->spi_dev.tmp_read_kbuf[0] ==
+		     MISO_VAL_ON_WRITE_SUCCESS) &&
+		    (ret == 0)) {
+			count = count - PREFIX_LENGTH;
+			break;
+		}
+		if ((nfc_dev->spi_dev.tmp_read_kbuf[0] !=
+		     MISO_VAL_ON_WRITE_SUCCESS) &&
+		    (retry_cnt >= max_retry_cnt)) {
+			pr_debug("%s, Write failed returning -1 ", __func__);
+			return 0;
+		} else if (ret <= 0 && (nfc_dev->spi_dev.tmp_read_kbuf[0] !=
+					MISO_VAL_ON_WRITE_SUCCESS)) {
+			pr_warn("%s: write failed ret(%d), maybe in standby\n",
+				__func__, ret);
+			usleep_range(WRITE_RETRY_WAIT_TIME_US,
+				     WRITE_RETRY_WAIT_TIME_US + 100);
+		}
+	}
+	return count;
+}
+
+ssize_t nfc_spi_dev_read(struct file *filp, char __user *buf, size_t count,
+			 loff_t *offset)
+{
+	int ret;
+	struct nfc_dev *nfc_dev = (struct nfc_dev *)filp->private_data;
+
+	if (filp->f_flags & O_NONBLOCK) {
+		pr_err("%s: f_flags has nonblock. try again\n", __func__);
+		return -EAGAIN;
+	}
+	mutex_lock(&nfc_dev->read_mutex);
+	ret = nfc_spi_read(nfc_dev, nfc_dev->read_kbuf, count, 0);
+	if (ret > 0) {
+		if (copy_to_user(buf, nfc_dev->read_kbuf, ret)) {
+			pr_warn("%s: failed to copy to user space\n", __func__);
+			ret = -EFAULT;
+		}
+	}
+	mutex_unlock(&nfc_dev->read_mutex);
+	return ret;
+}
+
+ssize_t nfc_spi_dev_write(struct file *filp, const char __user *buf,
+			  size_t count, loff_t *offset)
+{
+	int ret;
+	struct nfc_dev *nfc_dev = (struct nfc_dev *)filp->private_data;
+
+	if (count > MAX_DL_BUFFER_SIZE)
+		count = MAX_DL_BUFFER_SIZE;
+
+	mutex_lock(&nfc_dev->write_mutex);
+	if (copy_from_user(add_spi_write_prefix(nfc_dev->write_kbuf), buf,
+			   count)) {
+		pr_err("%s: failed to copy from user space\n", __func__);
+		mutex_unlock(&nfc_dev->write_mutex);
+		return -EFAULT;
+	}
+	ret = nfc_spi_write(nfc_dev, nfc_dev->write_kbuf,
+			 get_spi_command_length(count), NO_RETRY);
+	mutex_unlock(&nfc_dev->write_mutex);
+	return ret;
+}
+
+static const struct file_operations nfc_spi_dev_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.read = nfc_spi_dev_read,
+	.write = nfc_spi_dev_write,
+	.open = nfc_dev_open,
+	.release = nfc_dev_close,
+	.unlocked_ioctl = nfc_dev_ioctl,
+};
+
+int nfc_spi_dev_probe(struct spi_device *client)
+{
+	int ret = 0;
+	struct nfc_dev *nfc_dev = NULL;
+	struct spi_dev *spi_dev = NULL;
+	struct platform_configs nfc_configs;
+	struct platform_gpio *nfc_gpio = &nfc_configs.gpio;
+	unsigned int max_speed_hz;
+	struct device_node *np = client->dev.of_node;
+
+	pr_debug("%s: enter\n", __func__);
+	/* retrieve details of gpios from dt */
+	ret = nfc_parse_dt(&client->dev, &nfc_configs, PLATFORM_IF_SPI);
+	if (ret) {
+		pr_err("%s: failed to parse dt\n", __func__);
+		goto err;
+	}
+
+	nfc_dev = kzalloc(sizeof(struct nfc_dev), GFP_KERNEL);
+	if (nfc_dev == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+	nfc_dev->read_kbuf = kzalloc(MAX_NCI_BUFFER_SIZE, GFP_DMA | GFP_KERNEL);
+	if (!nfc_dev->read_kbuf) {
+		ret = -ENOMEM;
+		goto err_free_nfc_dev;
+	}
+	nfc_dev->write_kbuf = kzalloc(MAX_DL_BUFFER_SIZE + PREFIX_LENGTH,
+				      GFP_DMA | GFP_KERNEL);
+	if (!nfc_dev->write_kbuf) {
+		ret = -ENOMEM;
+		goto err_free_read_kbuf;
+	}
+	nfc_dev->interface = PLATFORM_IF_SPI;
+	nfc_dev->nfc_state = NFC_STATE_NCI;
+	nfc_dev->spi_dev.client = client;
+	spi_dev = &nfc_dev->spi_dev;
+	nfc_dev->nfc_read = nfc_spi_read;
+	nfc_dev->nfc_write = nfc_spi_write;
+	nfc_dev->nfc_enable_intr = spi_enable_irq;
+	nfc_dev->nfc_disable_intr = spi_disable_irq;
+	client->bits_per_word = 8;
+	client->mode = SPI_MODE_0;
+	ret = of_property_read_u32(np, "spi-max-frequency", &max_speed_hz);
+	if (ret < 0) {
+		pr_err("%s: There's no spi-max-frequency property\n", __func__);
+		goto err_free_write_kbuf;
+	}
+	client->max_speed_hz = max_speed_hz;
+	pr_info("%s: device tree set SPI clock Frequency %u\n", __func__,
+		client->max_speed_hz);
+
+	spi_dev->tmp_write_kbuf = kzalloc(PREFIX_LENGTH, GFP_DMA | GFP_KERNEL);
+	if (!spi_dev->tmp_write_kbuf) {
+		ret = -ENOMEM;
+		goto err_free_write_kbuf;
+	}
+	spi_dev->tmp_read_kbuf = kzalloc(MAX_DL_BUFFER_SIZE + PREFIX_LENGTH,
+					 GFP_DMA | GFP_KERNEL);
+	if (!spi_dev->tmp_read_kbuf) {
+		ret = -ENOMEM;
+		goto err_free_tmp_write_kbuf;
+	}
+	ret = spi_setup(client);
+	if (ret < 0) {
+		pr_err("%s: failed to do spi_setup()\n", __func__);
+		goto err_free_tmp_read_kbuf;
+	}
+	ret = configure_gpio(nfc_gpio->ven, GPIO_OUTPUT);
+	if (ret) {
+		pr_err("%s: unable to request nfc reset gpio [%d]\n", __func__,
+		       nfc_gpio->ven);
+		goto err_free_tmp_read_kbuf;
+	}
+	ret = configure_gpio(nfc_gpio->irq, GPIO_IRQ);
+	if (ret <= 0) {
+		pr_err("%s: unable to request nfc irq gpio [%d]\n", __func__,
+		       nfc_gpio->irq);
+		goto err_free_gpio;
+	}
+	client->irq = ret;
+	ret = configure_gpio(nfc_gpio->dwl_req, GPIO_OUTPUT);
+	if (ret) {
+		pr_err("%s: unable to request nfc firm downl gpio [%d]\n",
+		       __func__, nfc_gpio->dwl_req);
+	}
+
+	/* copy the retrieved gpio details from DT */
+	memcpy(&nfc_dev->configs, &nfc_configs,
+	       sizeof(struct platform_configs));
+
+	/* init mutex and queues */
+	init_waitqueue_head(&nfc_dev->read_wq);
+	mutex_init(&nfc_dev->read_mutex);
+	mutex_init(&nfc_dev->write_mutex);
+	mutex_init(&nfc_dev->dev_ref_mutex);
+	spin_lock_init(&spi_dev->irq_enabled_lock);
+	ret = nfc_misc_register(nfc_dev, &nfc_spi_dev_fops, DEV_COUNT,
+				NFC_CHAR_DEV_NAME, CLASS_NAME);
+	if (ret) {
+		pr_err("%s: nfc_misc_register failed\n", __func__);
+		goto err_mutex_destroy;
+	}
+	/* interrupt initializations */
+	pr_info("%s: requesting IRQ %d\n", __func__, client->irq);
+	spi_dev->irq_enabled = true;
+	ret = request_irq(client->irq, spi_irq_handler, IRQF_TRIGGER_HIGH,
+			  spi_dev->device.name, nfc_dev);
+	if (ret) {
+		pr_err("%s: request_irq failed\n", __func__);
+		goto err_nfc_misc_unregister;
+	}
+	spi_disable_irq(nfc_dev);
+	gpio_set_ven(nfc_dev, 1);
+	gpio_set_ven(nfc_dev, 0);
+	gpio_set_ven(nfc_dev, 1);
+	device_init_wakeup(&client->dev, true);
+	spi_set_drvdata(client, nfc_dev);
+	spi_dev->irq_wake_up = false;
+
+	pr_info("%s: probing nfc spi successfully\n", __func__);
+	return 0;
+err_nfc_misc_unregister:
+	nfc_misc_unregister(nfc_dev, DEV_COUNT);
+err_mutex_destroy:
+	mutex_destroy(&nfc_dev->dev_ref_mutex);
+	mutex_destroy(&nfc_dev->read_mutex);
+	mutex_destroy(&nfc_dev->write_mutex);
+err_free_gpio:
+	gpio_free_all(nfc_dev);
+err_free_tmp_read_kbuf:
+	if(spi_dev)
+		kfree(spi_dev->tmp_read_kbuf);
+err_free_tmp_write_kbuf:
+	if(spi_dev)
+		kfree(spi_dev->tmp_write_kbuf);
+err_free_write_kbuf:
+	kfree(nfc_dev->write_kbuf);
+err_free_read_kbuf:
+	kfree(nfc_dev->read_kbuf);
+err_free_nfc_dev:
+	kfree(nfc_dev);
+err:
+	pr_err("%s: probing not successful, check hardware\n", __func__);
+	return ret;
+}
+
+int nfc_spi_dev_remove(struct spi_device *client)
+{
+	int ret = 0;
+	struct nfc_dev *nfc_dev = NULL;
+
+	pr_info("%s: remove device\n", __func__);
+	nfc_dev = dev_get_drvdata(&client->dev);
+	if (!nfc_dev) {
+		pr_err("%s: device doesn't exist anymore\n", __func__);
+		ret = -ENODEV;
+		return ret;
+	}
+	if (nfc_dev->dev_ref_count > 0) {
+		pr_err("%s: device already in use\n", __func__);
+		return -EBUSY;
+	}
+	device_init_wakeup(&client->dev, false);
+	free_irq(client->irq, nfc_dev);
+	nfc_misc_unregister(nfc_dev, DEV_COUNT);
+	mutex_destroy(&nfc_dev->read_mutex);
+	mutex_destroy(&nfc_dev->write_mutex);
+	gpio_free_all(nfc_dev);
+	kfree(nfc_dev->read_kbuf);
+	kfree(nfc_dev->write_kbuf);
+	kfree(nfc_dev);
+	return ret;
+}
+
+int nfc_spi_dev_suspend(struct device *device)
+{
+	struct spi_device *client = to_spi_device(device);
+	struct nfc_dev *nfc_dev = dev_get_drvdata(&client->dev);
+	struct spi_dev *spi_dev = &nfc_dev->spi_dev;
+
+	if (device_may_wakeup(&client->dev) && spi_dev->irq_enabled) {
+		if (!enable_irq_wake(client->irq))
+			spi_dev->irq_wake_up = true;
+	}
+	return 0;
+}
+
+int nfc_spi_dev_resume(struct device *device)
+{
+	struct spi_device *client = to_spi_device(device);
+	struct nfc_dev *nfc_dev = dev_get_drvdata(&client->dev);
+	struct spi_dev *spi_dev = &nfc_dev->spi_dev;
+
+	if (device_may_wakeup(&client->dev) && spi_dev->irq_wake_up) {
+		if (!disable_irq_wake(client->irq))
+			spi_dev->irq_wake_up = false;
+	}
+	return 0;
+}
+
+static const struct of_device_id nfc_dev_match_table[] = {
+	{
+		.compatible = NFC_DRV_STR,
+	},
+	{}
+};
+
+static const struct dev_pm_ops nfc_spi_dev_pm_ops = { SET_SYSTEM_SLEEP_PM_OPS(
+	nfc_spi_dev_suspend, nfc_spi_dev_resume) };
+
+static struct spi_driver nfc_spi_dev_driver = {
+	.probe = nfc_spi_dev_probe,
+	.remove = nfc_spi_dev_remove,
+	.driver = {
+		.name = NFC_DEV_ID,
+		.pm = &nfc_spi_dev_pm_ops,
+		.of_match_table = nfc_dev_match_table,
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+	},
+};
+
+MODULE_DEVICE_TABLE(of, nfc_dev_match_table);
+
+static int __init nfc_spi_dev_init(void)
+{
+	int ret = 0;
+
+	pr_info("%s: Loading NXP NFC SPI driver\n", __func__);
+	ret = spi_register_driver(&nfc_spi_dev_driver);
+	if (ret != 0)
+		pr_err("%s: NFC SPI add driver error ret %d\n", __func__, ret);
+	return ret;
+}
+
+module_init(nfc_spi_dev_init);
+
+static void __exit nfc_spi_dev_exit(void)
+{
+	pr_info("%s: Unloading NXP NFC SPI driver\n", __func__);
+	spi_unregister_driver(&nfc_spi_dev_driver);
+}
+
+module_exit(nfc_spi_dev_exit);
+MODULE_ALIAS("spi:nxpnfc");
+MODULE_DESCRIPTION("NXP NFC SPI driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/nxp-pn7160/nfc/spi_drv.h b/drivers/misc/nxp-pn7160/nfc/spi_drv.h
new file mode 100755
index 000000000000..aff9adc7620a
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/nfc/spi_drv.h
@@ -0,0 +1,56 @@
+/******************************************************************************
+ * Copyright (C) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2019-2021 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ******************************************************************************/
+#ifndef _SPI_DRV_H_
+#define _SPI_DRV_H_
+#include <linux/spi/spi.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+
+/*kept same as dts */
+#define NFC_DRV_STR			"nxp,nxpnfc"
+#define NFC_DEV_ID			"nxpnfc"
+#define WRITE_PREFIX_ON_WRITE		(0x7F)
+#define WRITE_PREFIX_ON_READ		(0xFF)
+#define PREFIX_LENGTH			1
+#define PREFIX_INDEX			0
+#define MISO_VAL_ON_WRITE_SUCCESS	(0xFF)
+
+/* Interface specific parameters */
+struct spi_dev {
+	struct spi_device *client;
+	struct miscdevice   device;
+	/* IRQ parameters */
+	bool irq_enabled;
+	spinlock_t irq_enabled_lock;
+	/* NFC_IRQ wake-up state */
+	bool irq_wake_up;
+	/* Temparary write kernel buffer used for spi_write_then_read() API to write 0xFF byte*/
+	uint8_t *tmp_write_kbuf;
+	/* Temparary read kernel buffer used for spi_sync() API to write 0x7F byte as a prefix for the command*/
+	uint8_t *tmp_read_kbuf;
+};
+
+int nfc_spi_dev_probe(struct spi_device *client);
+int nfc_spi_dev_remove(struct spi_device *client);
+int nfc_spi_dev_suspend(struct device *device);
+int nfc_spi_dev_resume(struct device *device);
+uint8_t *add_spi_write_prefix(uint8_t *cmd);
+uint8_t *add_write_prefix_for_spi_read(uint8_t *cmd);
+#endif //_SPI_DRV_H_
diff --git a/drivers/misc/nxp-pn7160/spi_devicetree.txt b/drivers/misc/nxp-pn7160/spi_devicetree.txt
new file mode 100644
index 000000000000..d8c32467b847
--- /dev/null
+++ b/drivers/misc/nxp-pn7160/spi_devicetree.txt
@@ -0,0 +1,13 @@
+Example:
+
+spi2: spi@ffd68000 {
+	status = "ok";
+	nxpnfc@0 {
+		compatible = "nxp,nxpnfc";
+		reg = <0>;
+		nxp,nxpnfc-irq = <&gpio26 0 0>;
+		nxp,nxpnfc-ven = <&gpio26 2 0>;
+		nxp,nxpnfc-fw-dwnld = <&gpio26 4 0>;
+		spi-max-frequency = <7000000>;
+    };
+};
