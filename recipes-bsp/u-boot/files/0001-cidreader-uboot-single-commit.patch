From f82860f3b29f2cfda306c52c6d1f99d6ad2efbdf Mon Sep 17 00:00:00 2001
From: Pavan Nittala <Pavan.Nittala@credenceid.com>
Date: Tue, 21 Jan 2025 13:00:36 +0000
Subject: [PATCH] cidreader single commit

---
 arch/arm/dts/imx8mm-c2.dts              |  74 ++++--
 arch/arm/dts/imx8mm.dtsi                |   2 -
 arch/arm/dts/panel-afr480360a0.dtsi     |  88 +++++++
 arch/arm/include/asm/mach-imx/fbpanel.h |  32 ++-
 board/boundary/c2-imx8mm/c2-imx8mm.c    | 210 ++++++++++++++++-
 board/boundary/c2-imx8mm/spl.c          |  20 ++
 board/boundary/common/Kconfig           |   2 +-
 board/boundary/common/Makefile          |   2 +-
 board/boundary/common/bd_common.c       |   2 +
 board/boundary/common/max77823.c        |  11 +-
 cmd/mmc.c                               |   4 +
 common/autoboot.c                       |   6 +
 common/avb_verify.c                     | 190 +++++++--------
 configs/c2-imx8mm_2g_defconfig          |   1 +
 disk/part_efi.c                         |  29 +++
 drivers/fastboot/fb_command.c           | 294 ++++++++++++++++++++++--
 drivers/fastboot/fb_common.c            |  22 ++
 drivers/fastboot/fb_getvar.c            |  14 +-
 include/configs/c2-imx8mm.h             |   2 +
 include/fastboot.h                      |  18 ++
 include/mmc.h                           |   1 +
 include/part.h                          |   2 +
 lib/libavb/avb_slot_verify.c            |  79 ++++++-
 23 files changed, 945 insertions(+), 160 deletions(-)
 create mode 100644 arch/arm/dts/panel-afr480360a0.dtsi

diff --git a/arch/arm/dts/imx8mm-c2.dts b/arch/arm/dts/imx8mm-c2.dts
index a9a0a6b2ab0..286173e2ea1 100644
--- a/arch/arm/dts/imx8mm-c2.dts
+++ b/arch/arm/dts/imx8mm-c2.dts
@@ -21,12 +21,14 @@
 #ifdef UBOOT
 #include "bd-universal.h"
 #include "panel-dlc0350gev06.dtsi"
+#include "panel-afr480360a0.dtsi"
 #include "panel-ltk080a60a004t.dtsi"
 #include "panel-m101nwwb.dtsi"
 #else
 #include "../bd-universal.h"
 #include "../panel-dlc0350gev06.dtsi"
 #include "../panel-ltk080a60a004t.dtsi"
+#include "../panel-afr480360a0.dtsi"
 #include "../panel-m101nwwb.dtsi"
 #endif
 
@@ -44,6 +46,27 @@
 			MX8MMN(IOMUXC_GPIO1_IO06_GPIO1_IO6, 0x149)
 		>;
 	};
+	pinctrl_fec1: fec1grp {
+        	fsl,pins = <
+#define GPIRQ_FEC1_PHY  <&gpio3 16 IRQ_TYPE_LEVEL_HIGH>
+            		MX8MMN(IOMUXC_NAND_READY_B_GPIO3_IO16, 0x159)
+            		MX8MMN(IOMUXC_ENET_RD0_ENET1_RGMII_RD0, 0x91)
+            		MX8MMN(IOMUXC_ENET_RD1_ENET1_RGMII_RD1, 0x91)
+            		MX8MMN(IOMUXC_ENET_RD2_ENET1_RGMII_RD2, 0x91)
+            		MX8MMN(IOMUXC_ENET_RD3_ENET1_RGMII_RD3, 0x91)
+            		MX8MMN(IOMUXC_ENET_RXC_ENET1_RGMII_RXC, 0x91)
+            		MX8MMN(IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL, 0x91)
+            		MX8MMN(IOMUXC_ENET_TD0_ENET1_RGMII_TD0, 0x1f)
+            		MX8MMN(IOMUXC_ENET_TD1_ENET1_RGMII_TD1, 0x1f)
+            		MX8MMN(IOMUXC_ENET_TD2_ENET1_RGMII_TD2, 0x1f)
+            		MX8MMN(IOMUXC_ENET_TD3_ENET1_RGMII_TD3, 0x1f)
+            		MX8MMN(IOMUXC_ENET_TXC_ENET1_RGMII_TXC, 0x1f)
+            		MX8MMN(IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL, 0x1f)
+#define GP_MII_MDC  <&gpio1 16 GPIO_PULSE_HIGH>
+            		MX8MMN(IOMUXC_ENET_MDC_GPIO1_IO16, 0x00)
+#define GP_MII_MDIO <&gpio1 17 GPIO_ACTIVE_HIGH>
+        >;
+    	};
 
 	pinctrl_hog: hoggrp {
 		fsl,pins = <
@@ -109,12 +132,16 @@
 		fsl,pins = <
 #define GPIRQ_MAX77818_WCHG_VALID_INT	<&gpio5 0 IRQ_TYPE_LEVEL_LOW>
 			MX8MMN(IOMUXC_SAI3_TXC_GPIO5_IO0, 0x149)
-#define GPIRQ_MAX77818_WCHG_VALID	<&gpio4 31 IRQ_TYPE_LEVEL_LOW>
-			MX8MMN(IOMUXC_SAI3_TXFS_GPIO4_IO31, 0x149)
 #define GPIRQ_MAX77818_CHG_INT		<&gpio1 5 IRQ_TYPE_LEVEL_LOW>
 			MX8MMN(IOMUXC_GPIO1_IO05_GPIO1_IO5, 0x149)
 		>;
 	};
+    	pinctrl_i2c2_pca9546: i2c2-pca9546grp {
+        	fsl,pins = <
+#define GP_I2C2_PCA9546_RESET   <&gpio1 9 GPIO_ACTIVE_LOW>
+           	 	MX8MMN(IOMUXC_GPIO1_IO09_GPIO1_IO9, 0x106)
+        >;
+    	};
 
 	pinctrl_i2c3: i2c3grp {
 		fsl,pins = <
@@ -140,6 +167,21 @@
 			MX8MMN(IOMUXC_GPIO1_IO09_GPIO1_IO9, 0x106)
 		>;
 	};
+	pinctrl_mipi_dlc0350gev06: mipi-dlc0350gev06grp {
+		fsl,pins = <
+/* Reset pin used as enable */
+#define GP_DLC0350_ENABLE	<&gpio1 3 GPIO_ACTIVE_HIGH>
+			MX8MMN(IOMUXC_GPIO1_IO03_GPIO1_IO3, 0x16)
+		>;
+	};
+
+        pinctrl_mipi_afr480360a0: mipi-afr480360a0 {
+                fsl,pins = <
+/* Reset pin used as enable */
+#define GP_AFR480_ENABLE       <&gpio1 3 GPIO_ACTIVE_HIGH>
+                        MX8MMN(IOMUXC_GPIO1_IO03_GPIO1_IO3, 0x16)
+                >;
+        };
 
 	pinctrl_ts_gt911: ts-gt911grp {
 		fsl,pins = <
@@ -535,12 +577,6 @@
 			default-state = "off";
 			retain-state-suspended;
 		};
-
-		vibrator {
-			gpios = GP_LED_VIBRATOR;
-			default-state = "off";
-			linux,default-trigger = "transient";
-		};
 	};
 
 	reg_usbotg2: regulator-usbotg2 {
@@ -1061,12 +1097,12 @@
 		clock-names = "mipi_clk", "pixel_clock";
 		compatible = "panel,common";
 		dsi-format = "rgb888";
-		dsi-lanes = <4>;
+		dsi-lanes = <2>;
 		mode-skip-eot;
 		mode-video;
 		mode-video-burst;
-		panel-height-mm = <136>;
-		panel-width-mm = <217>;
+		panel-height-mm = <47>;
+		panel-width-mm = <42>;
 		pinctrl-names = "sn65dsi83";
 		pinctrl-0 = <&pinctrl_sn65dsi83>;
 		power-supply = <&reg_vref_5v>;
@@ -1078,14 +1114,14 @@
 			t_mipi: t-dsi-default {
 				/* m101nwwb by default */
 				clock-frequency = <66000000>;
-				hactive = <1280>;
-				vactive = <800>;
-				hback-porch = <5>;
-				hfront-porch = <123>;
-				vback-porch = <3>;
-				vfront-porch = <24>;
-				hsync-len = <1>;
-				vsync-len = <1>;
+				hactive = <480>;
+				vactive = <360>;
+				hback-porch = <40>;
+				hfront-porch = <20>;
+				vback-porch = <44>;
+				vfront-porch = <20>;
+				hsync-len = <4>;
+				vsync-len = <4>;
 				hsync-active = <0>;
 				vsync-active = <0>;
 				de-active = <1>;
diff --git a/arch/arm/dts/imx8mm.dtsi b/arch/arm/dts/imx8mm.dtsi
index 6a1f18b67bd..f1a28519dba 100644
--- a/arch/arm/dts/imx8mm.dtsi
+++ b/arch/arm/dts/imx8mm.dtsi
@@ -1018,8 +1018,6 @@
 				clocks = <&clk IMX8MM_CLK_UART4_ROOT>,
 					 <&clk IMX8MM_CLK_UART4_ROOT>;
 				clock-names = "ipg", "per";
-				dmas = <&sdma1 28 4 0>, <&sdma1 29 4 0>;
-				dma-names = "rx", "tx";
 				status = "disabled";
 			};
 
diff --git a/arch/arm/dts/panel-afr480360a0.dtsi b/arch/arm/dts/panel-afr480360a0.dtsi
new file mode 100644
index 00000000000..9398cf3d95f
--- /dev/null
+++ b/arch/arm/dts/panel-afr480360a0.dtsi
@@ -0,0 +1,88 @@
+#include <dt-bindings/display/simple_panel_mipi_cmds.h>
+
+#define PAGE(page) DCS_L3P(0xff, 0x98, 0x81, page)
+
+/ {
+	aliases {
+		mipi_cmds_afr480360a0 = &mipi_cmds_afr480360a0;
+		pinctrl_afr480360a0 = &pinctrl_mipi_afr480360a0;
+	};
+
+	mipi_cmds_afr480360a0: mipi-cmds-afr480360a0 {
+		alias = <&mipi_cmds_afr480360a0>;
+		aliasp = <&pinctrl_mipi_afr480360a0>;
+		delay-prepare = <150>;
+		mipi-cmds-enable = /bits/ 8 <
+			PAGE(3)
+			DCS_L5P(0xFF, 0x77, 0x01, 0x00, 0x00, 0x13)
+			DCS_S1P(0xEF, 0x08)
+			PAGE(1)
+			DCS_L5P(0xFF, 0x77, 0x01, 0x00, 0x00, 0x10)
+			DCS_L2P(0xC0, 0x2C, 0x00)
+			DCS_L2P(0xC1, 0x10, 0x0C)
+			DCS_L2P(0xC2, 0x21, 0x0A)
+			DCS_S1P(0xCC, 0x10)
+			0x11
+			  0xB0 0x00 0x12 0x9A 0x0E 0x12 0x07 0x0B 0x08 0x09 0x26 0x05 0x51 0x0F 0x69 0x30 0x1C
+			0x11
+			  0xB1 0x00 0x12 0x9B 0x0D 0x10 0x06 0x0B 0x09 0x08 0x25 0x03 0x50 0x0F 0x68 0x30 0x1C
+			PAGE(1)
+			DCS_L5P(0xFF, 0x77, 0x01, 0x00, 0x00, 0x11)
+			DCS_S1P(0xB0, 0x5D)
+			DCS_S1P(0xB1, 0x66)
+			DCS_S1P(0xB2, 0x84)
+			DCS_S1P(0xB3, 0x80)
+			DCS_S1P(0xB5, 0x4E)
+			DCS_S1P(0xB7, 0x85)
+			DCS_S1P(0xB8, 0x20)
+			DCS_S1P(0xC1, 0x78)
+			DCS_S1P(0xC2, 0x78)
+			DCS_S1P(0xD0, 0x88)
+			DCS_L3P(0xE0, 0x00, 0x00, 0x02)
+			0x0C
+			  0xE1 0x06 0xA0 0x08 0xA0 0x05 0xA0 0x07 0xA0 0x00 0x44 0x44
+			0x0D
+			  0xE2 0x00 0x00 0x44 0x44 0x01 0xA0 0x00 0x00 0x01 0xA0 0x00 0x00
+			DCS_L4P(0xE3, 0x00, 0x00, 0x11, 0x11)
+			DCS_L2P(0xE4, 0x44, 0x44)
+			0x11
+			  0xE5 0x0D 0x79 0x0A 0xA0 0x0F 0x7B 0x0A 0xA0 0x09 0x75 0x0A 0xA0 0x0B 0x77 0x0A 0xA0
+			DCS_L4P(0xE6, 0x00, 0x00, 0x11, 0x11)
+			DCS_L2P(0xE7, 0x44, 0x44)
+			0x11
+			  0xE8 0x0C 0x78 0x0A 0xA0 0x0E 0x7A 0x0A 0xA0 0x08 0x74 0x0A 0xA0 0x0A 0x76 0x0A 0xA0
+			DCS_L2P(0xE9, 0x36, 0x00)
+			0x08
+			  0xEB 0x00 0x01 0xE4 0xE4 0x44 0x80 0x40
+			0x11
+			  0xED 0xFF 0x45 0x67 0xFA 0x01 0x2B 0xAB 0xFF 0xFF 0xBA 0xB2 0x10 0xAF 0x76 0x54 0xFF
+			0x07
+			  0xEF 0x10 0x0D 0x04 0x08 0x3F 0x1F
+			DCS_L5P(0xFF, 0x77, 0x01, 0x00, 0x00, 0x00)
+			DCS_L5P(0xFF, 0x77, 0x01, 0x00, 0x00, 0x13)
+			DCS_L2P(0xE8, 0x00, 0x0E)
+			DCS_S0P(0x11)
+			DELAY(120)
+			DCS_L2P(0xE8, 0x00, 0x0C)
+			DELAY(10)
+			DCS_L2P(0xE8, 0x00,0x00)
+			DCS_L5P(0xFF, 0x77, 0x01, 0x00, 0x00, 0x00)
+			DCS_S1P(0x3A, 0x70)
+			DCS_S0P(0x29)
+			DELAY(20)
+			/* Exit Sleep */
+			DCS_S0P(0x11)
+			DELAY(120)
+			DCS_S0P(0x29)
+		>;
+		mipi-cmds-disable = /bits/ 8 <
+			DCS_S0P(0x28)		/* MIPI_DCS_SET_DISPLAY_OFF */
+			DELAY(20)
+			DCS_S0P(0x10)		/* Enter sleep */
+		>;
+		mipi-delay-between-cmds = <1>;
+		mode-video-hbp-disable;
+		mode-video-hfp-disable;
+		mode-video-hsa-disable;
+	};
+};
diff --git a/arch/arm/include/asm/mach-imx/fbpanel.h b/arch/arm/include/asm/mach-imx/fbpanel.h
index a9e36783fba..cdd7f48f90f 100644
--- a/arch/arm/include/asm/mach-imx/fbpanel.h
+++ b/arch/arm/include/asm/mach-imx/fbpanel.h
@@ -179,6 +179,7 @@ struct display_info_t {
 #define FBF_U_TM070JDHG30	(FBF_MODE_SKIP_EOT | FBF_MODE_VIDEO | FBF_MODE_VIDEO_SYNC_PULSE | FBF_MIPI_CMDS | FBF_DSI_LANES_4 | FBF_DSI_HBP | FBF_DSI_HFP | FBF_DSI_HSA)
 #define FBF_UT_TM070JDHG30	(FBF_MODE_SKIP_EOT | FBF_MODE_VIDEO | FBF_MODE_VIDEO_SYNC_PULSE | FBF_MIPI_CMDS | FBF_DSI_LANES_4 | FBF_DSI_HBP | FBF_DSI_HFP | FBF_DSI_HSA | FBF_SN65_ALT)
 #define FBF_DLC0350GEV06	(FBF_MODE_SKIP_EOT | FBF_MODE_VIDEO | FBF_MODE_VIDEO_BURST | FBF_MIPI_CMDS | FBF_DSI_LANES_4 | FBF_PINCTRL | FBF_ENABLE_GPIOS_DTB)
+#define FBF_AFR480360A0         (FBF_MODE_SKIP_EOT | FBF_MODE_VIDEO | FBF_MODE_VIDEO_BURST | FBF_MIPI_CMDS | FBF_DSI_LANES_2 | FBF_PINCTRL | FBF_ENABLE_GPIOS_DTB | FBF_ENABLE_GPIOS_OPEN_DRAIN)
 #define FBF_COM35H3R04ULY	(FBF_MODE_SKIP_EOT | FBF_MODE_VIDEO | FBF_MODE_VIDEO_SYNC_PULSE | FBF_MIPI_CMDS | FBF_DSI_LANES_4 | FBF_PINCTRL | FBF_ENABLE_GPIOS_DTB)
 #define FBF_LCD133_070		(FBF_MODE_SKIP_EOT | FBF_MODE_VIDEO | FBF_MODE_VIDEO_BURST | FBF_MIPI_CMDS | FBF_DSI_LANES_4 | FBF_PINCTRL | FBF_ENABLE_GPIOS_DTB)
 #define FBF_TCXD070		(FBF_MODE_SKIP_EOT | FBF_MODE_VIDEO | FBF_MODE_VIDEO_BURST | FBF_MIPI_CMDS | FBF_DSI_LANES_4 | FBF_PINCTRL | FBF_BKLIT_EN_DTB | FBF_ENABLE_GPIOS_DTB)
@@ -349,6 +350,7 @@ void fbp_setup_env_cmds(void);
 #define VD_MIPI_AM_TFT1280X800W(_mode, args...)	VDF_AM_TFT1280X800W(_mode, "am-tft1280x800w", RGB24, FBF_AM_TFT1280X800W, args)
 #define VD_MIPI_MTD0900DCP27KF(_mode, args...)	VDF_MIPI_MTD0900DCP27KF(_mode, "mtd0900dcp27kf", RGB24, FBF_MTD0900DCP27KF, args)
 #define VD_MIPI_DLC0350GEV06(_mode, args...)	VDF_MIPI_DLC0350GEV06(_mode, "dlc0350gev06", RGB24, FBF_DLC0350GEV06, args)
+#define VD_MIPI_AFR480360A0(_mode, args...)	VDF_MIPI_AFR480360A0(_mode, "afr480360a0", RGB24, FBF_AFR480360A0, args)
 #define VD_MIPI_COM35H3R04ULY(_mode, args...)	VDF_MIPI_COM35H3R04ULY(_mode, "com35h3r04uly", RGB24, FBF_COM35H3R04ULY, args)
 #define VD_MIPI_LCD133_070(_mode, args...)	VDF_MIPI_LCD133_070(_mode, "lcd133_070", RGB24, FBF_LCD133_070, args)
 #define VD_MIPI_X090DTLNC01(_mode, args...)	VDF_MIPI_X090DTLNC01(_mode, "x090dtlnc01", RGB24, FBF_B_M101NWWB, args)
@@ -1879,13 +1881,13 @@ void fbp_setup_env_cmds(void);
 		.refresh	= 60,\
 		.xres		= 640,\
 		.yres		= 960,\
-		.pixclock_f	= (640+80+80+12)*(960+30+20+1)*60,\
-		.left_margin	= 80,\
-		.right_margin	= 80,\
+		.pixclock_f	= (640+100+100+33)*(960+30+20+2)*60,\
+		.left_margin	= 100,\
+		.right_margin	= 100,\
 		.upper_margin	= 30,\
 		.lower_margin	= 20,\
-		.hsync_len	= 12,\
-		.vsync_len	= 1,\
+		.hsync_len	= 33,\
+		.vsync_len	= 2,\
 		.sync           = FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
 		.vmode          = FB_VMODE_NONINTERLACED\
 	}\
@@ -1934,6 +1936,26 @@ void fbp_setup_env_cmds(void);
 	}\
 }
 
+#define VDF_MIPI_AFR480360A0(_mode, _name, _fmt, _flags, args...) \
+{\
+        VD_HEADER(_mode, _fmt, _flags, args),\
+        .mode   = {\
+                .name           = _name,\
+                .refresh        = 60,\
+                .xres           = 480,\
+                .yres           = 360,\
+                .pixclock_f     = (480+100+100+33)*(360+30+20+2)*60,\
+                .left_margin    = 100,\
+                .right_margin   = 100,\
+                .upper_margin   = 30,\
+                .lower_margin   = 20,\
+                .hsync_len      = 4,\
+                .vsync_len      = 4,\
+                .sync           = FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+                .vmode          = FB_VMODE_NONINTERLACED\
+        }\
+}
+
 #define VDF_MIPI_LCD133_070(_mode, _name, _fmt, _flags, args...) \
 {\
 	VD_HEADER(_mode, _fmt, _flags, args),\
diff --git a/board/boundary/c2-imx8mm/c2-imx8mm.c b/board/boundary/c2-imx8mm/c2-imx8mm.c
index e8021c14272..338ad4a974c 100644
--- a/board/boundary/c2-imx8mm/c2-imx8mm.c
+++ b/board/boundary/c2-imx8mm/c2-imx8mm.c
@@ -31,9 +31,20 @@
 #include <i2c.h>
 #include <linux/delay.h>
 #include <spl.h>
+#include <string.h>
 #include "../common/padctrl.h"
 #include "../common/bd_common.h"
 
+#define LED1_ADDR "0x34"
+#define LED2_ADDR "0x35"
+#define EN_ADDR "0x00"
+#define EN_LED "0x40"
+#define MUX_ADDR "0x70"
+#define BUS_NUM 3
+int rst_pressed;
+
+static struct udevice *i2c_cur_bus;
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #define UART_PAD_CTRL	(PAD_CTL_DSE6 | PAD_CTL_FSEL1)
@@ -42,6 +53,13 @@ static iomux_v3_cfg_t const init_pads[] = {
 	IOMUX_PAD_CTRL(GPIO1_IO02__WDOG1_WDOG_B, WDOG_PAD_CTRL),
 	IOMUX_PAD_CTRL(UART2_RXD__UART2_DCE_RX, UART_PAD_CTRL),
 	IOMUX_PAD_CTRL(UART2_TXD__UART2_DCE_TX, UART_PAD_CTRL),
+   // IOMUX_PAD_CTRL(UART4_RXD__UART4_RX, 0x140),
+   // IOMUX_PAD_CTRL(UART4_TXD__UART4_TX, 0x140),
+    /* uart4 */
+//    IOMUX_PAD_CTRL(UART4_TXD__UART4_DCE_TX, UART_PAD_CTRL),
+  //  IOMUX_PAD_CTRL(UART4_RXD__UART4_DCE_RX, UART_PAD_CTRL),
+    IOMUX_PAD_CTRL(UART4_TXD__UART4_TX, UART_PAD_CTRL),
+    IOMUX_PAD_CTRL(UART4_RXD__UART4_RX, UART_PAD_CTRL),
 
 #define GPIRQ_SN65DSI83			IMX_GPIO_NR(1, 1)
 #define GP_LTK08_MIPI_EN		IMX_GPIO_NR(1, 1)
@@ -56,6 +74,9 @@ static iomux_v3_cfg_t const init_pads[] = {
 #define GP_GT911_RESET			IMX_GPIO_NR(5, 23)
 	IOMUX_PAD_CTRL(UART1_TXD__GPIO5_IO23, 0x109),
 
+//#define GP_LED_VIBRATOR    IMX_GPIO_NR(3, 24)
+//    IOMUX_PAD_CTRL(SAI5_RXD3__GPIO3_IO24, 0x149),
+
 #define GP_SN65DSI83_EN		IMX_GPIO_NR(1, 9)
 #define GP_MIPI_RESET		IMX_GPIO_NR(1, 9)
 /* enable for TPS65132 Single Inductor - Dual Output Power Supply */
@@ -81,6 +102,15 @@ static iomux_v3_cfg_t const init_pads[] = {
 
 #define GP_FASTBOOT_KEY		IMX_GPIO_NR(1, 7)
 	IOMUX_PAD_CTRL(GPIO1_IO07__GPIO1_IO7, WEAK_PULLUP),
+
+#define GP_I2C4_PCA9546_RESET   IMX_GPIO_NR(1, 9)
+        IOMUX_PAD_CTRL(GPIO1_IO09__GPIO1_IO9, 0x106),
+#define GP_LED1_EN     IMX_GPIO_NR(2, 13)
+        IOMUX_PAD_CTRL(SD2_CLK__GPIO2_IO13, 0x149),
+#define GP_LED2_EN     IMX_GPIO_NR(2, 12)
+        IOMUX_PAD_CTRL(SD2_CD_B__GPIO2_IO12, 0x149),
+ #define GP_FEC1_RESET  IMX_GPIO_NR(3,15)
+        IOMUX_PAD_CTRL(NAND_RE_B__GPIO3_IO15, 0x159),
 };
 
 #if defined(CONFIG_CMD_FASTBOOT) || defined(CONFIG_CMD_DFU)
@@ -122,7 +152,8 @@ void board_enable_mipi(const struct display_info_t *di, int enable)
 }
 
 static const struct display_info_t displays[] = {
-	VD_MIPI_DLC0350GEV06(MIPI, board_detect_gt911, fbp_bus_gp(2, 0, GP_DLC0350_ENABLE, 0), fbp_addr_gp(0x5d, 0, 0, 0), FBTS_GOODIX),
+	VD_MIPI_AFR480360A0(MIPI, board_detect_gt911, fbp_bus_gp(2, 0, GP_LTK08_MIPI_EN, 0), fbp_addr_gp(0x5d, 0, 0, 0), FBTS_GOODIX),
+	VD_MIPI_DLC0350GEV06(MIPI, board_detect_gt911, fbp_bus_gp(2, 0, GP_LTK08_MIPI_EN, 0), fbp_addr_gp(0x5d, 0, 0, 0), FBTS_GOODIX),
 	VD_LTK080A60A004T(MIPI, NULL, fbp_bus_gp(2, GP_LTK08_MIPI_EN, GP_LTK08_MIPI_EN, 0), 0x5d, FBP_BACKLIGHT_MIPI_ALT, FBTS_GOODIX),
 	VD_MIPI_M101NWWB_x("m101nwwb-1", B, MIPI, fbp_detect_i2c, fbp_bus_gp(2, GP_SN65DSI83_EN, 0, 0), 0x2c, FBP_MIPI_TO_LVDS, FBTS_FT5X06),
 	VD_MIPI_1280_720M_60(MIPI, NULL, fbp_bus_gp((2 | (3 << 4)), 0, 0, 0), 0x68, FBP_PCA9546),
@@ -134,6 +165,178 @@ static const struct display_info_t displays[] = {
 #define display_cnt	0
 #endif
 
+static int i2c_get_cur_bus(struct udevice **busp)
+{
+#ifdef CONFIG_I2C_SET_DEFAULT_BUS_NUM
+    if (!i2c_cur_bus) {
+        if (cmd_i2c_set_bus_num(CONFIG_I2C_DEFAULT_BUS_NUMBER)) {
+            printf("Default I2C bus %d not found\n",
+                  CONFIG_I2C_DEFAULT_BUS_NUMBER);
+            return -ENODEV;
+        }
+    }
+#endif
+    if (!i2c_cur_bus) {
+        puts("No I2C bus selected\n");
+        return -ENODEV;
+    }
+    *busp = i2c_cur_bus;
+    return 0;
+}
+static int i2c_get_cur_bus_chip(uint chip_addr, struct udevice **devp)
+{
+    struct udevice *bus;
+    int ret;
+
+    ret = i2c_get_cur_bus(&bus);
+    if (ret)
+        return ret;
+
+    return i2c_get_chip(bus, chip_addr, 1, devp);
+}
+int ident_i2c_set_bus_num(int busnum)
+{
+    struct udevice *bus;
+    int ret;
+
+    ret = uclass_get_device_by_seq(UCLASS_I2C, busnum, &bus);
+    if (ret) {
+        debug("%s: No bus %d\n", __func__, busnum);
+        return ret;
+    }
+    i2c_cur_bus = bus;
+
+    return 0;
+}
+int max_i2cmux_init(void)
+{
+    ulong addr;
+    uint chip;
+    uchar byte;
+    int ret, i;
+    struct udevice *dev;
+
+    addr = simple_strtoul("0x00", NULL, 16);
+    ret = ident_i2c_set_bus_num(1);
+    if (ret) {
+        printf("error set bus num\n");
+        return 1;
+    }
+    chip = simple_strtoul("0x70", NULL, 16);
+    ret = i2c_get_cur_bus_chip(chip, &dev);
+    if(ret) {
+        printf("error get cur bus\n");
+        return 1;
+    }
+    byte = simple_strtoul("0x08", NULL, 16);
+    ret = dm_i2c_write(dev, addr++, &byte, 1);
+    if (ret) {
+        printf("error write\n");
+        return 1;
+    }
+    return 0;
+}
+int led_init()
+{
+    ulong addr;
+    uint chip;
+    uchar byte;
+    int ret, i;
+    struct udevice *dev;
+
+    ret = ident_i2c_set_bus_num(BUS_NUM);
+    if (ret) {
+        printf("error set bus num\n");
+        return 1;
+    }
+    chip = simple_strtoul(MUX_ADDR, NULL, 16);
+    ret = i2c_get_cur_bus_chip(chip, &dev);
+    if(ret) {
+        printf("error get cur bus\n");
+        return 1;
+    }
+
+    addr = simple_strtoul(EN_ADDR, NULL, 16);
+    byte = simple_strtoul("0xff", NULL, 16);
+    ret = dm_i2c_write(dev, addr, &byte, 1);
+    if (ret) {
+        printf("error write\n");
+        return 1;
+    }
+
+    chip = simple_strtoul(LED1_ADDR, NULL, 16);
+    addr = simple_strtoul(EN_ADDR, NULL, 16);
+    byte = simple_strtoul(EN_LED, NULL, 16);
+
+    for (i = 0; i < 2; i++) {
+        ret = i2c_get_cur_bus_chip(chip++, &dev);
+        if(ret) {
+            printf("error get cur bus\n");
+            return 1;
+        }
+
+        ret = dm_i2c_write(dev, addr, &byte, 1);
+        if (ret) {
+            printf("error write\n");
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+#if 1
+int board_init(void)
+{
+
+#ifndef CONFIG_DM_VIDEO
+	gpio_request(GP_SN65DSI83_EN, "sn65dsi83_enable");
+	gpio_request(GP_LTK08_MIPI_EN, "lkt08_mipi_en");
+	gpio_request(GP_BACKLIGHT_MIPI2, "backlight_pwm2");
+#endif
+
+    if(board_fastboot_key_pressed())
+    {
+        printf("Reset button pressed, Starting fastboot...\n");
+        rst_pressed = 1;
+    }
+	gpio_request(GP_DLC0350_ENABLE, "dlc0350 reset");
+	gpio_request(GP_GT911_RESET, "gt911_reset");
+    	gpio_direction_output(GP_DLC0350_ENABLE, 1);
+	gpio_request(GPIRQ_GT911, "gt911_irq");
+	gpio_request(GP_CSI1_OV5640_MIPI_RESET, "csi1_mipi_reset");
+    	gpio_set_value(GP_DLC0350_ENABLE, 0);
+    	mdelay(40);
+	gpio_direction_output(GP_CSI1_OV5640_MIPI_RESET, 0);
+	gpio_direction_output(GP_GT911_RESET, 0);
+    	gpio_set_value(GP_DLC0350_ENABLE, 1);
+
+    /* Enable PCA9546 and LP55231 */
+    	gpio_request(GP_I2C4_PCA9546_RESET, "pca9546_reset");
+    	gpio_direction_output(GP_I2C4_PCA9546_RESET, 0);
+    	mdelay(40);
+    	gpio_direction_output(GP_I2C4_PCA9546_RESET, 1);
+
+
+/* KSZ9031 chip needs delay before data transmission and also before reset is going HIGH */
+    	gpio_request(GP_FEC1_RESET, "ethernet_reset");
+    	gpio_direction_output(GP_FEC1_RESET,0);
+    	mdelay(20);//20 miliseconds of delay
+    	gpio_direction_output(GP_FEC1_RESET,1);
+    	mdelay(0.01); //10 microseconds of delay
+
+#if defined(CONFIG_MXC_SPI) && !defined(CONFIG_DM_SPI)
+	setup_spi();
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+	fbp_setup_display(displays, display_cnt);
+#endif
+	return 0;
+}
+
+#else
+
 int board_init(void)
 {
 #ifndef CONFIG_DM_VIDEO
@@ -164,14 +367,15 @@ int board_init(void)
 #endif
 	return 0;
 }
+#endif
 
 void board_poweroff(void)
 {
 	struct snvs_regs *snvs = (struct snvs_regs *)(SNVS_BASE_ADDR);
 
 #ifdef CONFIG_MAX77823
-	max77823_otg_power(0);
-	max77823_boost_power(0);
+//	max77823_otg_power(0);
+//	max77823_boost_power(0);
 #endif
 	writel(0x60, &snvs->lpcr);
 	mdelay(500);
diff --git a/board/boundary/c2-imx8mm/spl.c b/board/boundary/c2-imx8mm/spl.c
index 44f79a50446..b47dc84813e 100644
--- a/board/boundary/c2-imx8mm/spl.c
+++ b/board/boundary/c2-imx8mm/spl.c
@@ -30,6 +30,7 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 #define I2C_PAD_CTRL	(PAD_CTL_DSE1 | PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PE)
+#define WEAK_PULLUP     (PAD_CTL_DSE6 | PAD_CTL_FSEL2 | PAD_CTL_PE | PAD_CTL_PUE | PAD_CTL_HYS)
 
 struct i2c_pads_info i2c_pad_info1[] = {
 {
@@ -99,12 +100,24 @@ static iomux_v3_cfg_t const init_pads[] = {
 	IOMUX_PAD_CTRL(SD1_DATA7__USDHC1_DATA7, USDHC_PAD_CTRL),
 #define GP_EMMC_RESET	IMX_GPIO_NR(2, 10)
 	IOMUX_PAD_CTRL(SD1_RESET_B__GPIO2_IO10, 0x41),
+  //  #define GP_LED_VIBRATOR    IMX_GPIO_NR(3, 24)
+  //  IOMUX_PAD_CTRL(SAI5_RXD3__GPIO3_IO24, 0x149),
+    #define GP_FASTBOOT_KEY     IMX_GPIO_NR(1, 7)
+    IOMUX_PAD_CTRL(GPIO1_IO07__GPIO1_IO7, WEAK_PULLUP),
 };
 
 struct fsl_esdhc_cfg board_usdhc_cfg[] = {
 	{.esdhc_base = USDHC1_BASE_ADDR, .bus_width = 8, .gp_reset = GP_EMMC_RESET},
 };
 
+int board_fastboot_key_pressed_spl(void)
+{
+    gpio_request(GP_FASTBOOT_KEY, "fastboot_key");
+    gpio_direction_input(GP_FASTBOOT_KEY);
+    return !gpio_get_value(GP_FASTBOOT_KEY);
+}
+
+
 int power_init_boundary(void)
 {
 	int ret;
@@ -192,6 +205,12 @@ void spl_board_init(void)
 		restore_boot_params();
 	}
 #endif
+
+    if(!board_fastboot_key_pressed_spl())
+    {
+   // gpio_request(GP_LED_VIBRATOR, "gpio_vibrator");
+  //  gpio_direction_output(GP_LED_VIBRATOR, 1);
+    }
 	puts("Normal Boot\n");
 }
 
@@ -213,6 +232,7 @@ void board_init_f(ulong dummy)
 	arch_cpu_init();
 
 	init_uart_clk(1);
+	init_uart_clk(3);
 
 	board_early_init_f();
 
diff --git a/board/boundary/common/Kconfig b/board/boundary/common/Kconfig
index 2e99bbbcde8..213493f4a82 100644
--- a/board/boundary/common/Kconfig
+++ b/board/boundary/common/Kconfig
@@ -21,7 +21,7 @@ config LOGO_BMP
 
 config MAX77823
 	bool
-	default y if TARGET_C2_IMX8MM
+	default n if TARGET_C2_IMX8MM
 	default y if TARGET_CID
 	default y if TARGET_CID_TAB
 	default y if TARGET_H4
diff --git a/board/boundary/common/Makefile b/board/boundary/common/Makefile
index 34394f5c699..fcf72f0f6cc 100644
--- a/board/boundary/common/Makefile
+++ b/board/boundary/common/Makefile
@@ -30,7 +30,7 @@ obj-$(CONFIG_IMX8ULP) += lpddr4_timing_8ulp.o
 endif
 obj-$(CONFIG_CMD_FBPANEL) += display.o
 obj-$(CONFIG_BQ25898) += bq25898.o
-obj-$(CONFIG_MAX77823)  += max77823.o
+# obj-$(CONFIG_MAX77823)  += max77823.o
 obj-$(CONFIG_MAX77975)  += max77975.o
 obj-$(CONFIG_FAN53526)  += fan53526.o
 obj-$(CONFIG_CMD_OTG_CABLE)  += cmd_otg_cable.o
diff --git a/board/boundary/common/bd_common.c b/board/boundary/common/bd_common.c
index 7e04a29a1f8..53e033137e8 100644
--- a/board/boundary/common/bd_common.c
+++ b/board/boundary/common/bd_common.c
@@ -42,6 +42,8 @@ DECLARE_GLOBAL_DATA_PTR;
 #define MEM_SIZE	SDRAM_SIZE
 #endif
 
+#undef CONFIG_MAX77823
+
 #if defined(CONFIG_IMX8M)
 int board_phys_sdram_size(phys_size_t *sdram_size)
 {
diff --git a/board/boundary/common/max77823.c b/board/boundary/common/max77823.c
index c9f3f65a755..e99aba17b8e 100644
--- a/board/boundary/common/max77823.c
+++ b/board/boundary/common/max77823.c
@@ -329,6 +329,7 @@ static int usbmisc_imx7d_init(void)
 	reg &= ~TXVREFTUNE0_MASK;
 	reg |= (7 << TXVREFTUNE0_BIT);
 
+    reg &= ~BIT(12);
 	writel(reg, base + MX7D_USB_OTG_PHY_CFG1);
 	return 0;
 }
@@ -346,9 +347,9 @@ static int init_usbphy(BUS_PARM_ u8 i2c_addr, u8 *pchgin)
 	ret = imx7d_charger_data_contact_detect();
 
 	if (ret < 0) {
-		ilim_max = 0x78;	/* Charger */
+		ilim_max = 0x3f;	/* Charger */
 	} else {
-		ilim_max = 0xf;		/* Standard downstream port */
+		ilim_max = 0x3f;	/* Standard downstream port */
 	}
 
 	ret = max77823_read_reg(bus, i2c_addr, MAX77823_CHG_CNFG_09);
@@ -598,10 +599,8 @@ void max77823_init(void)
 	BUS_T bus = get_bus();
 	u8 val8;
 
-#ifndef CONFIG_OTG_CHARGER
-	val8 = 0x78;	/* 4.0A source */
-	max77823_write_reg(bus, I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_09, val8);
-#endif
+    val8 = 0x3f;    /* 2.1A source */
+    max77823_write_reg(bus, I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_09, val8);
 	val8 = 0x26;	/* .76 A source */
 	max77823_write_reg(bus, I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_10, val8);
 	val8 = 0x0c;	/* Protection allow 0xb9 write */
diff --git a/cmd/mmc.c b/cmd/mmc.c
index 7464f8d00cd..94a764dd07d 100644
--- a/cmd/mmc.c
+++ b/cmd/mmc.c
@@ -370,6 +370,10 @@ static int do_mmc_read(struct cmd_tbl *cmdtp, int flag,
 	return (n == cnt) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 
+struct mmc *temp_init_mmc_device(int curr_dev, bool val) {
+    return init_mmc_device(curr_dev, val);
+}
+
 #if CONFIG_IS_ENABLED(CMD_MMC_SWRITE)
 static lbaint_t mmc_sparse_write(struct sparse_storage *info, lbaint_t blk,
 				 lbaint_t blkcnt, const void *buffer)
diff --git a/common/autoboot.c b/common/autoboot.c
index 5af239993fa..169a9bc1a1d 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -27,6 +27,7 @@
 #include <crypt.h>
 #include <dm/ofnode.h>
 
+extern int rst_pressed;
 DECLARE_GLOBAL_DATA_PTR;
 
 #define DELAY_STOP_STR_MAX_LENGTH 64
@@ -366,6 +367,11 @@ static int abortboot_single_key(int bootdelay)
 	int abort = 0;
 	unsigned long ts;
 
+    if(rst_pressed)
+{
+        printf("Device in fastboot mode... \n");
+        run_command("fastboot 0",0);
+}
 	printf("Hit any key to stop autoboot: %2d ", bootdelay);
 
 	/*
diff --git a/common/avb_verify.c b/common/avb_verify.c
index 0520a714556..5ce50fa1f4d 100644
--- a/common/avb_verify.c
+++ b/common/avb_verify.c
@@ -14,110 +14,92 @@
 #include <tee/optee_ta_avb.h>
 
 static const unsigned char avb_root_pub[1032] = {
-	0x0, 0x0, 0x10, 0x0, 0x55, 0xd9, 0x4, 0xad, 0xd8, 0x4,
-	0xaf, 0xe3, 0xd3, 0x84, 0x6c, 0x7e, 0xd, 0x89, 0x3d, 0xc2,
-	0x8c, 0xd3, 0x12, 0x55, 0xe9, 0x62, 0xc9, 0xf1, 0xf, 0x5e,
-	0xcc, 0x16, 0x72, 0xab, 0x44, 0x7c, 0x2c, 0x65, 0x4a, 0x94,
-	0xb5, 0x16, 0x2b, 0x0, 0xbb, 0x6, 0xef, 0x13, 0x7, 0x53,
-	0x4c, 0xf9, 0x64, 0xb9, 0x28, 0x7a, 0x1b, 0x84, 0x98, 0x88,
-	0xd8, 0x67, 0xa4, 0x23, 0xf9, 0xa7, 0x4b, 0xdc, 0x4a, 0xf,
-	0xf7, 0x3a, 0x18, 0xae, 0x54, 0xa8, 0x15, 0xfe, 0xb0, 0xad,
-	0xac, 0x35, 0xda, 0x3b, 0xad, 0x27, 0xbc, 0xaf, 0xe8, 0xd3,
-	0x2f, 0x37, 0x34, 0xd6, 0x51, 0x2b, 0x6c, 0x5a, 0x27, 0xd7,
-	0x96, 0x6, 0xaf, 0x6b, 0xb8, 0x80, 0xca, 0xfa, 0x30, 0xb4,
-	0xb1, 0x85, 0xb3, 0x4d, 0xaa, 0xaa, 0xc3, 0x16, 0x34, 0x1a,
-	0xb8, 0xe7, 0xc7, 0xfa, 0xf9, 0x9, 0x77, 0xab, 0x97, 0x93,
-	0xeb, 0x44, 0xae, 0xcf, 0x20, 0xbc, 0xf0, 0x80, 0x11, 0xdb,
-	0x23, 0xc, 0x47, 0x71, 0xb9, 0x6d, 0xd6, 0x7b, 0x60, 0x47,
-	0x87, 0x16, 0x56, 0x93, 0xb7, 0xc2, 0x2a, 0x9a, 0xb0, 0x4c,
-	0x1, 0xc, 0x30, 0xd8, 0x93, 0x87, 0xf0, 0xed, 0x6e, 0x8b,
-	0xbe, 0x30, 0x5b, 0xf6, 0xa6, 0xaf, 0xdd, 0x80, 0x7c, 0x45,
-	0x5e, 0x8f, 0x91, 0x93, 0x5e, 0x44, 0xfe, 0xb8, 0x82, 0x7,
-	0xee, 0x79, 0xca, 0xbf, 0x31, 0x73, 0x62, 0x58, 0xe3, 0xcd,
-	0xc4, 0xbc, 0xc2, 0x11, 0x1d, 0xa1, 0x4a, 0xbf, 0xfe, 0x27,
-	0x7d, 0xa1, 0xf6, 0x35, 0xa3, 0x5e, 0xca, 0xdc, 0x57, 0x2f,
-	0x3e, 0xf0, 0xc9, 0x5d, 0x86, 0x6a, 0xf8, 0xaf, 0x66, 0xa7,
-	0xed, 0xcd, 0xb8, 0xed, 0xa1, 0x5f, 0xba, 0x9b, 0x85, 0x1a,
-	0xd5, 0x9, 0xae, 0x94, 0x4e, 0x3b, 0xcf, 0xcb, 0x5c, 0xc9,
-	0x79, 0x80, 0xf7, 0xcc, 0xa6, 0x4a, 0xa8, 0x6a, 0xd8, 0xd3,
-	0x31, 0x11, 0xf9, 0xf6, 0x2, 0x63, 0x2a, 0x1a, 0x2d, 0xd1,
-	0x1a, 0x66, 0x1b, 0x16, 0x41, 0xbd, 0xbd, 0xf7, 0x4d, 0xc0,
-	0x4a, 0xe5, 0x27, 0x49, 0x5f, 0x7f, 0x58, 0xe3, 0x27, 0x2d,
-	0xe5, 0xc9, 0x66, 0xe, 0x52, 0x38, 0x16, 0x38, 0xfb, 0x16,
-	0xeb, 0x53, 0x3f, 0xe6, 0xfd, 0xe9, 0xa2, 0x5e, 0x25, 0x59,
-	0xd8, 0x79, 0x45, 0xff, 0x3, 0x4c, 0x26, 0xa2, 0x0, 0x5a,
-	0x8e, 0xc2, 0x51, 0xa1, 0x15, 0xf9, 0x7b, 0xf4, 0x5c, 0x81,
-	0x9b, 0x18, 0x47, 0x35, 0xd8, 0x2d, 0x5, 0xe9, 0xad, 0xf,
-	0x35, 0x74, 0x15, 0xa3, 0x8e, 0x8b, 0xcc, 0x27, 0xda, 0x7c,
-	0x5d, 0xe4, 0xfa, 0x4, 0xd3, 0x5, 0xb, 0xba, 0x3a, 0xb2,
-	0x49, 0x45, 0x2f, 0x47, 0xc7, 0xd, 0x41, 0x3f, 0x97, 0x80,
-	0x4d, 0x3f, 0xc1, 0xb5, 0xbb, 0x70, 0x5f, 0xa7, 0x37, 0xaf,
-	0x48, 0x22, 0x12, 0x45, 0x2e, 0xf5, 0xf, 0x87, 0x92, 0xe2,
-	0x84, 0x1, 0xf9, 0x12, 0xf, 0x14, 0x15, 0x24, 0xce, 0x89,
-	0x99, 0xee, 0xb9, 0xc4, 0x17, 0x70, 0x70, 0x15, 0xea, 0xbe,
-	0xc6, 0x6c, 0x1f, 0x62, 0xb3, 0xf4, 0x2d, 0x16, 0x87, 0xfb,
-	0x56, 0x1e, 0x45, 0xab, 0xae, 0x32, 0xe4, 0x5e, 0x91, 0xed,
-	0x53, 0x66, 0x5e, 0xbd, 0xed, 0xad, 0xe6, 0x12, 0x39, 0xd,
-	0x83, 0xc9, 0xe8, 0x6b, 0x6c, 0x2d, 0xa5, 0xee, 0xc4, 0x5a,
-	0x66, 0xae, 0x8c, 0x97, 0xd7, 0xd, 0x6c, 0x49, 0xc7, 0xf5,
-	0xc4, 0x92, 0x31, 0x8b, 0x9, 0xee, 0x33, 0xda, 0xa9, 0x37,
-	0xb6, 0x49, 0x18, 0xf8, 0xe, 0x60, 0x45, 0xc8, 0x33, 0x91,
-	0xef, 0x20, 0x57, 0x10, 0xbe, 0x78, 0x2d, 0x83, 0x26, 0xd6,
-	0xca, 0x61, 0xf9, 0x2f, 0xe0, 0xbf, 0x5, 0x30, 0x52, 0x5a,
-	0x12, 0x1c, 0x0, 0xa7, 0x5d, 0xcc, 0x7c, 0x2e, 0xc5, 0x95,
-	0x8b, 0xa3, 0x3b, 0xf0, 0x43, 0x2e, 0x5e, 0xdd, 0x0, 0xdb,
-	0xd, 0xb3, 0x37, 0x99, 0xa9, 0xcd, 0x9c, 0xb7, 0x43, 0xf7,
-	0x35, 0x44, 0x21, 0xc2, 0x82, 0x71, 0xab, 0x8d, 0xaa, 0xb4,
-	0x41, 0x11, 0xec, 0x1e, 0x8d, 0xfc, 0x14, 0x82, 0x92, 0x4e,
-	0x83, 0x6a, 0xa, 0x6b, 0x35, 0x5e, 0x5d, 0xe9, 0x5c, 0xcc,
-	0x8c, 0xde, 0x39, 0xd1, 0x4a, 0x5b, 0x5f, 0x63, 0xa9, 0x64,
-	0xe0, 0xa, 0xcb, 0xb, 0xb8, 0x5a, 0x7c, 0xc3, 0xb, 0xe6,
-	0xbe, 0xfe, 0x8b, 0xf, 0x7d, 0x34, 0x8e, 0x2, 0x66, 0x74,
-	0x1, 0x6c, 0xca, 0x76, 0xac, 0x7c, 0x67, 0x8, 0x2f, 0x3f,
-	0x1a, 0xa6, 0x2c, 0x60, 0xb3, 0xff, 0xda, 0x8d, 0xb8, 0x12,
-	0xc, 0x0, 0x7f, 0xcc, 0x50, 0xa1, 0x5c, 0x64, 0xa1, 0xe2,
-	0x5f, 0x32, 0x65, 0xc9, 0x9c, 0xbe, 0xd6, 0xa, 0x13, 0x87,
-	0x3c, 0x2a, 0x45, 0x47, 0xc, 0xca, 0x42, 0x82, 0xfa, 0x89,
-	0x65, 0xe7, 0x89, 0xb4, 0x8f, 0xf7, 0x1e, 0xe6, 0x23, 0xa5,
-	0xd0, 0x59, 0x37, 0x79, 0x92, 0xd7, 0xce, 0x3d, 0xfd, 0xe3,
-	0xa1, 0xb, 0xcf, 0x6c, 0x85, 0xa0, 0x65, 0xf3, 0x5c, 0xc6,
-	0x4a, 0x63, 0x5f, 0x6e, 0x3a, 0x3a, 0x2a, 0x8b, 0x6a, 0xb6,
-	0x2f, 0xbb, 0xf8, 0xb2, 0x4b, 0x62, 0xbc, 0x1a, 0x91, 0x25,
-	0x66, 0xe3, 0x69, 0xca, 0x60, 0x49, 0xb, 0xf6, 0x8a, 0xbe,
-	0x3e, 0x76, 0x53, 0xc2, 0x7a, 0xa8, 0x4, 0x17, 0x75, 0xf1,
-	0xf3, 0x3, 0x62, 0x1b, 0x85, 0xb2, 0xb0, 0xef, 0x80, 0x15,
-	0xb6, 0xd4, 0x4e, 0xdf, 0x71, 0xac, 0xdb, 0x2a, 0x4, 0xd4,
-	0xb4, 0x21, 0xba, 0x65, 0x56, 0x57, 0xe8, 0xfa, 0x84, 0xa2,
-	0x7d, 0x13, 0xe, 0xaf, 0xd7, 0x9a, 0x58, 0x2a, 0xa3, 0x81,
-	0x84, 0x8d, 0x9, 0xa0, 0x6a, 0xc1, 0xbb, 0xd9, 0xf5, 0x86,
-	0xac, 0xbd, 0x75, 0x61, 0x9, 0xe6, 0x8c, 0x3d, 0x77, 0xb2,
-	0xed, 0x30, 0x20, 0xe4, 0x0, 0x1d, 0x97, 0xe8, 0xbf, 0xc7,
-	0x0, 0x1b, 0x21, 0xb1, 0x16, 0xe7, 0x41, 0x67, 0x2e, 0xec,
-	0x38, 0xbc, 0xe5, 0x1b, 0xb4, 0x6, 0x23, 0x31, 0x71, 0x1c,
-	0x49, 0xcd, 0x76, 0x4a, 0x76, 0x36, 0x8d, 0xa3, 0x89, 0x8b,
-	0x4a, 0x7a, 0xf4, 0x87, 0xc8, 0x15, 0xf, 0x37, 0x39, 0xf6,
-	0x6d, 0x80, 0x19, 0xef, 0x5c, 0xa8, 0x66, 0xce, 0x1b, 0x16,
-	0x79, 0x21, 0xdf, 0xd7, 0x31, 0x30, 0xc4, 0x21, 0xdd, 0x34,
-	0x5b, 0xd2, 0x1a, 0x2b, 0x3e, 0x5d, 0xf7, 0xea, 0xca, 0x5,
-	0x8e, 0xb7, 0xcb, 0x49, 0x2e, 0xa0, 0xe3, 0xf4, 0xa7, 0x48,
-	0x19, 0x10, 0x9c, 0x4, 0xa7, 0xf4, 0x28, 0x74, 0xc8, 0x6f,
-	0x63, 0x20, 0x2b, 0x46, 0x24, 0x26, 0x19, 0x1d, 0xd1, 0x2c,
-	0x31, 0x6d, 0x5a, 0x29, 0xa2, 0x6, 0xa6, 0xb2, 0x41, 0xcc,
-	0xa, 0x27, 0x96, 0x9, 0x96, 0xac, 0x47, 0x65, 0x78, 0x68,
-	0x51, 0x98, 0xd6, 0xd8, 0xa6, 0x2d, 0xa0, 0xcf, 0xec, 0xe2,
-	0x74, 0xf2, 0x82, 0xe3, 0x97, 0xd9, 0x7e, 0xd4, 0xf8, 0xb,
-	0x70, 0x43, 0x3d, 0xb1, 0x7b, 0x97, 0x80, 0xd6, 0xcb, 0xd7,
-	0x19, 0xbc, 0x63, 0xb, 0xfd, 0x4d, 0x88, 0xfe, 0x67, 0xac,
-	0xb8, 0xcc, 0x50, 0xb7, 0x68, 0xb3, 0x5b, 0xd6, 0x1e, 0x25,
-	0xfc, 0x5f, 0x3c, 0x8d, 0xb1, 0x33, 0x7c, 0xb3, 0x49, 0x1,
-	0x3f, 0x71, 0x55, 0xe, 0x51, 0xba, 0x61, 0x26, 0xfa, 0xea,
-	0xe5, 0xb5, 0xe8, 0xaa, 0xcf, 0xcd, 0x96, 0x9f, 0xd6, 0xc1,
-	0x5f, 0x53, 0x91, 0xad, 0x5, 0xde, 0x20, 0xe7, 0x51, 0xda,
-	0x5b, 0x95, 0x67, 0xed, 0xf4, 0xee, 0x42, 0x65, 0x70, 0x13,
-	0xb, 0x70, 0x14, 0x1c, 0xc9, 0xe0, 0x19, 0xca, 0x5f, 0xf5,
-	0x1d, 0x70, 0x4b, 0x6c, 0x6, 0x74, 0xec, 0xb5, 0x2e, 0x77,
-	0xe1, 0x74, 0xa1, 0xa3, 0x99, 0xa0, 0x85, 0x9e, 0xf1, 0xac,
-	0xd8, 0x7e,
+  0x00, 0x00, 0x10, 0x00, 0x7d, 0x3a, 0x1e, 0xf5, 0xef, 0x82, 0xfb, 0xcb,
+  0x14, 0x69, 0x46, 0x00, 0xa1, 0xa0, 0xa9, 0x9f, 0x4e, 0xe6, 0xbf, 0x39,
+  0x67, 0x4f, 0x03, 0x84, 0x33, 0x3a, 0xc3, 0xa3, 0x15, 0xb7, 0x9c, 0xf5,
+  0xb3, 0xbf, 0xa1, 0x8d, 0x49, 0x00, 0xb8, 0x88, 0x13, 0x14, 0x99, 0x17,
+  0x99, 0xd4, 0xb1, 0x0a, 0xbd, 0x14, 0xfa, 0xce, 0xc1, 0x26, 0x60, 0xe3,
+  0xe2, 0x44, 0x0e, 0x91, 0x9f, 0x56, 0xa2, 0x40, 0x7a, 0x29, 0x30, 0x27,
+  0x7d, 0xb9, 0x8b, 0x18, 0x57, 0x6b, 0x35, 0x6b, 0x79, 0x39, 0xa6, 0x7c,
+  0x24, 0x3d, 0xa4, 0x1a, 0xc0, 0x46, 0x77, 0xba, 0x7a, 0x9b, 0xc7, 0xde,
+  0xda, 0x18, 0x9f, 0x87, 0x67, 0x44, 0xad, 0xe7, 0x9f, 0x7a, 0x18, 0xfb,
+  0x10, 0x08, 0x0f, 0x78, 0x49, 0x6a, 0x66, 0x0c, 0xd0, 0xe2, 0xe5, 0x69,
+  0x12, 0x46, 0xf4, 0x8b, 0x4d, 0x7c, 0x71, 0xfb, 0x55, 0xe9, 0xd5, 0x4a,
+  0x36, 0x7a, 0xf8, 0xee, 0x1c, 0x0f, 0x59, 0x07, 0x85, 0xb9, 0xce, 0x4f,
+  0x28, 0x35, 0x5c, 0x9d, 0xbd, 0xb6, 0xa2, 0x5e, 0x06, 0x90, 0xa9, 0x7c,
+  0x59, 0xd6, 0x8b, 0x4c, 0x9a, 0xa7, 0xc2, 0xa5, 0x90, 0x54, 0x5c, 0x7d,
+  0xaa, 0xf7, 0xc4, 0x3a, 0x9c, 0x35, 0x56, 0x56, 0xe1, 0x6b, 0x63, 0x19,
+  0xfd, 0x0c, 0x87, 0x9b, 0xb8, 0x96, 0x8d, 0xab, 0xe8, 0x74, 0xf1, 0x44,
+  0x3e, 0x55, 0xe2, 0x06, 0xff, 0xc6, 0x91, 0xdf, 0x3a, 0xb2, 0x3f, 0x7b,
+  0xcd, 0xbb, 0x04, 0x15, 0x62, 0x2c, 0xf6, 0x66, 0xab, 0x33, 0x85, 0x5a,
+  0x68, 0x02, 0xd0, 0x00, 0x57, 0xa8, 0x8d, 0x70, 0x66, 0x26, 0x1c, 0x97,
+  0x04, 0x17, 0x03, 0x72, 0x97, 0x3e, 0x04, 0xef, 0x44, 0x46, 0x74, 0xde,
+  0x92, 0xfd, 0x03, 0x2d, 0x8f, 0xb9, 0x3a, 0x9d, 0xbf, 0xf0, 0xe9, 0x78,
+  0xed, 0x62, 0x8a, 0x66, 0x60, 0x32, 0x8e, 0xab, 0x46, 0xde, 0xd4, 0xbd,
+  0x22, 0x33, 0x14, 0xb2, 0x28, 0x33, 0x01, 0x8b, 0x6d, 0xd2, 0x9c, 0xa0,
+  0xb9, 0xdc, 0x18, 0xa1, 0xde, 0x19, 0x61, 0x73, 0x6e, 0xc6, 0xae, 0x3c,
+  0x2a, 0x67, 0xc5, 0x2e, 0x48, 0xc7, 0x10, 0x3f, 0x69, 0x08, 0xa8, 0xd2,
+  0x39, 0x9f, 0x00, 0xa1, 0x31, 0xcc, 0xe6, 0xfd, 0xb7, 0x68, 0x39, 0x4d,
+  0x7d, 0xc5, 0x5b, 0x84, 0x74, 0x8b, 0x95, 0x90, 0x24, 0xfd, 0xbf, 0x49,
+  0xc3, 0x92, 0x9e, 0x57, 0x33, 0xc3, 0xee, 0xa1, 0xf5, 0x29, 0x62, 0xe7,
+  0xaa, 0xf2, 0xd9, 0xb9, 0x0f, 0x22, 0xed, 0x2c, 0xcb, 0x00, 0xa6, 0xc2,
+  0xe9, 0x40, 0x1b, 0xbd, 0xfc, 0x95, 0x52, 0x00, 0xa0, 0x0d, 0xc8, 0xa5,
+  0x81, 0x1e, 0xab, 0x1a, 0x29, 0x9f, 0xc9, 0x26, 0x33, 0x52, 0x38, 0x94,
+  0x6c, 0x57, 0x79, 0x14, 0xb6, 0xac, 0x5d, 0x45, 0xa8, 0x33, 0x3e, 0x41,
+  0x7f, 0xfc, 0xeb, 0x64, 0x98, 0xc3, 0xdb, 0x38, 0x87, 0x68, 0xd9, 0xb2,
+  0x01, 0x2c, 0x77, 0x31, 0xba, 0xdb, 0xa0, 0x85, 0x2c, 0xa9, 0x0a, 0x48,
+  0xa3, 0xf8, 0x6a, 0x8f, 0xab, 0xfc, 0x25, 0xd7, 0x01, 0x98, 0x33, 0xb3,
+  0xf3, 0xfb, 0x09, 0x52, 0xa1, 0x84, 0x27, 0xd8, 0x55, 0xac, 0xa1, 0xd0,
+  0xe8, 0x45, 0xc4, 0x0c, 0xab, 0x05, 0x64, 0x9a, 0x6b, 0x66, 0x23, 0xe5,
+  0xfa, 0xb8, 0xd6, 0x9c, 0x86, 0xea, 0xab, 0xd9, 0x5b, 0x87, 0x2e, 0x03,
+  0x5b, 0x47, 0x3e, 0x3d, 0xd4, 0x53, 0x19, 0x4e, 0x06, 0xe9, 0x12, 0x55,
+  0xd7, 0xcb, 0x87, 0xf0, 0xf8, 0xbc, 0xa9, 0x45, 0x28, 0x7e, 0xcc, 0x60,
+  0xcf, 0x73, 0x14, 0x8e, 0x9e, 0xac, 0x34, 0x69, 0xea, 0x96, 0x6d, 0x08,
+  0x5c, 0xbb, 0x62, 0xbc, 0xc5, 0x9c, 0xf3, 0x02, 0x96, 0xdf, 0x5b, 0x3a,
+  0x32, 0xcf, 0xe7, 0x51, 0x5c, 0xbd, 0x8f, 0xb8, 0xdd, 0xc1, 0xdb, 0x96,
+  0x23, 0xc2, 0xe2, 0xa3, 0xad, 0x5c, 0x4a, 0x67, 0x1d, 0xc6, 0x09, 0xc5,
+  0x97, 0x9a, 0xdd, 0xd1, 0x33, 0xf8, 0x86, 0xba, 0xd0, 0xbe, 0xca, 0x4b,
+  0x2b, 0x73, 0xc2, 0x9b, 0x21, 0xb1, 0x94, 0x0d, 0x7c, 0x89, 0xe8, 0x56,
+  0x72, 0xfa, 0x43, 0x51, 0x30, 0x75, 0xff, 0x1b, 0x91, 0x79, 0x64, 0xa4,
+  0xf7, 0xe1, 0x87, 0x86, 0x28, 0x68, 0x06, 0x6f, 0x76, 0x6c, 0x15, 0x8d,
+  0x60, 0x1f, 0x9c, 0x15, 0xac, 0x45, 0x74, 0xc7, 0xc5, 0x1b, 0xce, 0x8a,
+  0x36, 0x8b, 0xd5, 0x32, 0x11, 0xa0, 0x0d, 0x6c, 0x3f, 0xed, 0x37, 0xf5,
+  0x24, 0x1f, 0xcb, 0xfa, 0x37, 0x65, 0xdd, 0x80, 0x53, 0xab, 0x9d, 0xdf,
+  0xa7, 0xae, 0xc2, 0x91, 0x59, 0xe6, 0x38, 0x81, 0x33, 0x2c, 0x10, 0xa0,
+  0xc0, 0xcd, 0x13, 0x82, 0x75, 0x2a, 0x9f, 0xaa, 0x06, 0x04, 0x94, 0x86,
+  0xd4, 0x66, 0x30, 0x3a, 0x4b, 0x01, 0x98, 0x8a, 0x0a, 0x5d, 0xac, 0xa2,
+  0xe9, 0xf6, 0x81, 0xc3, 0x70, 0x0a, 0x8c, 0xeb, 0x9d, 0x5f, 0x9f, 0x2b,
+  0x34, 0xed, 0xa4, 0x21, 0x85, 0x48, 0x08, 0x2b, 0xa1, 0xe2, 0x06, 0x84,
+  0x2f, 0x46, 0x12, 0x30, 0x3e, 0xff, 0x7d, 0xbb, 0x1c, 0x90, 0x5c, 0xd5,
+  0x7a, 0x04, 0x4f, 0xae, 0xe3, 0x6c, 0x69, 0x66, 0x77, 0x7f, 0xdb, 0x34,
+  0x6e, 0xea, 0x40, 0x67, 0x3e, 0xb4, 0xcc, 0xdb, 0x62, 0x99, 0x79, 0x9a,
+  0x7b, 0x57, 0x36, 0x20, 0x56, 0xf8, 0x20, 0x73, 0x27, 0x42, 0xaf, 0xc3,
+  0xde, 0xd9, 0xff, 0xe9, 0xda, 0xf9, 0x68, 0xba, 0xe2, 0x9c, 0xeb, 0x99,
+  0x9d, 0x4d, 0x1e, 0x99, 0x11, 0x1d, 0xf5, 0xb8, 0x17, 0x58, 0x22, 0xed,
+  0x9b, 0xea, 0x2d, 0xfa, 0x69, 0x41, 0xef, 0xe3, 0x11, 0x4d, 0xa3, 0x45,
+  0xda, 0xeb, 0x6c, 0xae, 0xc9, 0x6f, 0xbf, 0x0c, 0xd5, 0xca, 0xc8, 0x34,
+  0xab, 0xad, 0x94, 0x0d, 0xdd, 0x88, 0x18, 0x23, 0x33, 0xbc, 0x6b, 0x38,
+  0x85, 0x48, 0xa8, 0x43, 0xd8, 0x0f, 0xe2, 0xec, 0x19, 0xb3, 0x07, 0xbc,
+  0x72, 0xe0, 0xde, 0x24, 0xfe, 0x93, 0x1c, 0xd9, 0x57, 0xcc, 0x3b, 0xcc,
+  0x86, 0xf7, 0xa6, 0x50, 0x91, 0xfe, 0xd3, 0x6f, 0xf1, 0x19, 0xab, 0x0b,
+  0x5e, 0x06, 0xd7, 0xb6, 0xeb, 0x90, 0x9a, 0xb1, 0x2a, 0x3e, 0x1e, 0xbd,
+  0x75, 0xd5, 0xc9, 0xbf, 0xe2, 0x27, 0xe5, 0x87, 0xeb, 0x0b, 0xdc, 0x19,
+  0xe7, 0xb8, 0x2c, 0x28, 0xed, 0xbc, 0x38, 0x45, 0xb8, 0x5c, 0x52, 0x1d,
+  0x00, 0xb1, 0x5d, 0x0f, 0x80, 0xab, 0x95, 0x92, 0x42, 0x99, 0xa3, 0x26,
+  0xe2, 0x36, 0x35, 0x6f, 0x1b, 0x31, 0x07, 0xc5, 0x8e, 0x88, 0x7e, 0x80,
+  0xb8, 0x37, 0x3a, 0xa9, 0xe0, 0x1a, 0xba, 0xc4, 0x3b, 0x7b, 0x09, 0xb8,
+  0x97, 0x5b, 0x5a, 0x55, 0x9e, 0x8d, 0x14, 0x26, 0xbb, 0xa3, 0xf5, 0xc5,
+  0xb3, 0x64, 0xab, 0x98, 0x3e, 0x2d, 0x59, 0x42, 0x52, 0x8e, 0x90, 0x26,
+  0xbd, 0xd4, 0xff, 0xcf, 0xb6, 0xc5, 0xa9, 0x25, 0x57, 0xff, 0x14, 0x14,
+  0x85, 0x00, 0xf2, 0xaa, 0x14, 0xee, 0x71, 0xd6, 0x95, 0xb4, 0x9a, 0x6e,
+  0x75, 0x0d, 0xc0, 0x98, 0x44, 0x5b, 0x28, 0x93, 0x63, 0x0e, 0xef, 0x1f,
+  0x11, 0x9d, 0x11, 0xbf, 0x54, 0xf5, 0x4c, 0x85, 0x1d, 0x1b, 0x1f, 0xe1,
+  0x15, 0x41, 0x82, 0x18, 0x7c, 0x09, 0x9d, 0x33, 0x36, 0x1c, 0x61, 0x10,
+  0xca, 0x7a, 0xda, 0xad, 0xfc, 0x58, 0xe3, 0x80, 0x71, 0x3d, 0x52, 0x5e,
+  0xeb, 0x38, 0x53, 0x4d, 0x48, 0x55, 0x1f, 0x6a, 0xe9, 0x18, 0xf5, 0xfd,
+  0x3b, 0xbd, 0x72, 0xf1, 0x1f, 0x98, 0xfd, 0x68, 0xcf, 0xb3, 0x2e, 0x9c,
+  0x56, 0x4f, 0x78, 0x5d, 0xcc, 0x78, 0x06, 0xff, 0x0b, 0xf3, 0xd1, 0xb5,
+  0x3a, 0x88, 0xdd, 0xa3, 0xab, 0xd2, 0x2b, 0x50, 0xa3, 0x75, 0x39, 0x71,
 };
 
 /**
diff --git a/configs/c2-imx8mm_2g_defconfig b/configs/c2-imx8mm_2g_defconfig
index e561f35c903..e714b08c0c5 100644
--- a/configs/c2-imx8mm_2g_defconfig
+++ b/configs/c2-imx8mm_2g_defconfig
@@ -137,6 +137,7 @@ CONFIG_SYSRESET=y
 CONFIG_SPL_SYSRESET=y
 CONFIG_SYSRESET_PSCI=y
 CONFIG_DM_THERMAL=y
+CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
 CONFIG_USB=y
 CONFIG_DM_USB=y
 # CONFIG_SPL_DM_USB is not set
diff --git a/disk/part_efi.c b/disk/part_efi.c
index f1f3e5bceff..7d497d28bef 100644
--- a/disk/part_efi.c
+++ b/disk/part_efi.c
@@ -27,6 +27,7 @@
 #include <linux/compiler.h>
 #include <linux/ctype.h>
 #include <u-boot/crc.h>
+#include <string.h>
 
 #ifdef CONFIG_HAVE_BLOCK_DEVICE
 
@@ -216,6 +217,34 @@ int get_disk_guid(struct blk_desc * dev_desc, char *guid)
 	return 0;
 }
 
+__le64 get_part_start_lba(struct blk_desc *dev_desc, char* part_name, int required_address)
+{
+    ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1, dev_desc->blksz);
+    gpt_entry *gpt_pte = NULL;
+    int i = 0;
+    __le64 lba_value;
+
+    /* This function validates AND fills in the GPT header and PTE */
+    if (find_valid_gpt(dev_desc, gpt_head, &gpt_pte) != 1)
+        return;
+    for (i = 0; i < le32_to_cpu(gpt_head->num_partition_entries); i++) {
+        /* Stop at the first non valid PTE */
+        if (!is_pte_valid(&gpt_pte[i]))
+            break;
+        if (strcmp(part_name, print_efiname(&gpt_pte[i])) == 0) {
+            if (required_address == 0)
+                lba_value = gpt_pte[i].starting_lba;
+            else
+                lba_value = gpt_pte[i].ending_lba;
+            free(gpt_pte);
+            return lba_value;
+        }
+    }
+    /* Remember to free pte */
+    free(gpt_pte);
+    return;
+}
+
 void part_print_efi(struct blk_desc *dev_desc)
 {
 	ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1, dev_desc->blksz);
diff --git a/drivers/fastboot/fb_command.c b/drivers/fastboot/fb_command.c
index 98eccc34556..1b7572daafe 100644
--- a/drivers/fastboot/fb_command.c
+++ b/drivers/fastboot/fb_command.c
@@ -14,6 +14,23 @@
 #include <part.h>
 #include <stdlib.h>
 
+#include <avb_verify.h>
+#include <image.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <blk.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm-generic/gpio.h>
+#include <asm/mach-imx/gpio.h>
+
+#define GP_LED_VIBRATOR    IMX_GPIO_NR(3, 24)
+
+
+//Credence flash unlock key
+#define UNLOCK_CREDENCE_KEY "0e50995840e7bdfaa229640d769df0ec17f2dc8c"
+
+static struct AvbOps *avb_ops;
+
 /**
  * image_size - final fastboot image size
  */
@@ -41,6 +58,9 @@ static void reboot_fastbootd(char *, char *);
 static void reboot_recovery(char *, char *);
 #if CONFIG_IS_ENABLED(FASTBOOT_CMD_OEM_FORMAT)
 static void oem_format(char *, char *);
+static void oem_lock(char *, char *);
+static void oem_unlock(char *, char *);
+static void oem_deviceinfo(char *, char *);
 #endif
 #if CONFIG_IS_ENABLED(FASTBOOT_CMD_OEM_PARTCONF)
 static void oem_partconf(char *, char *);
@@ -109,6 +129,18 @@ static const struct {
 		.command = "oem format",
 		.dispatch = oem_format,
 	},
+    [FASTBOOT_COMMAND_OEM_LOCK] = {
+        .command = "oem lock",
+        .dispatch = oem_lock
+    },
+    [FASTBOOT_COMMAND_OEM_UNLOCK] = {
+        .command = "oem unlock",
+        .dispatch = oem_unlock
+    }, 
+    [FASTBOOT_COMMAND_OEM_DEVICEINFO] = {
+        .command = "oem device-info",
+       .dispatch = oem_deviceinfo
+    },
 #endif
 #if CONFIG_IS_ENABLED(FASTBOOT_CMD_OEM_PARTCONF)
 	[FASTBOOT_COMMAND_OEM_PARTCONF] = {
@@ -155,16 +187,37 @@ int fastboot_handle_command(char *cmd_string, char *response)
 			if (commands[i].dispatch) {
 				commands[i].dispatch(cmd_parameter,
 							response);
-				return i;
-			} else {
+			    return i;
+            } else {
 				break;
 			}
 		}
-	}
+        else if ((i == FASTBOOT_COMMAND_OEM_UNLOCK )){
+             char *p = strstr(cmd_string,commands[i].command);
+             if (p)
+             {
+                 if (commands[i].dispatch) {
+                 
+                     //get the key
+                     char *tok = cmd_string, *end = cmd_string,*key=cmd_string;
+                     while (tok != NULL) {
+                         key = end;
+                         strsep(&end, " ");
+                         tok = end;
+                     }
+                     
+                     commands[i].dispatch(key,response);
+			           return i;
+                }
+                
+            }
+        }
+    }
 
 	pr_err("command %s not recognized.\n", cmd_string);
 	fastboot_fail("unrecognized command", response);
 	return -1;
+
 }
 
 /**
@@ -203,6 +256,8 @@ static void download(char *cmd_parameter, char *response)
 {
 	char *tmp;
 
+ if(fastboot_getDevLock()==true) {
+
 	if (!cmd_parameter) {
 		fastboot_fail("Expected command parameter", response);
 		return;
@@ -226,6 +281,10 @@ static void download(char *cmd_parameter, char *response)
 		       fastboot_bytes_expected);
 		fastboot_response("DATA", response, "%s", cmd_parameter);
 	}
+ } else {
+        fastboot_fail("Device is Locked!",response);
+ }
+
 }
 
 /**
@@ -312,14 +371,176 @@ void fastboot_data_complete(char *response)
  */
 static void flash(char *cmd_parameter, char *response)
 {
+    unsigned long mmc_dev=0;
+    bool unlocked = false;
+    int flash_err = -1, start_lba, end_lba;
+    const char * const requested_partitions[] = {"verifyimg", cmd_parameter, NULL};
+    AvbSlotVerifyResult slot_result;
+    AvbSlotVerifyData *out_data;
+    char *verifypart = "verifyimg";
+    char *slot_suffix = "";
+    struct blk_desc *dev_desc;
+
+    struct mmc *mmc;
+    u32 blk, cnt, n,cnt_actual,temp_cnt,blk_vimg,blk_part;
+    void *addr= NULL;
+    int curr_device=0;
+ if(fastboot_getDevLock()==true) {
+    if (strcmp(cmd_parameter, "recovery") == 0 || strcmp(cmd_parameter, "boot") == 0
+                                               || strcmp(cmd_parameter, "dtbo") == 0
+                                               || strcmp(cmd_parameter, "vendor") == 0
+                                               || strcmp(cmd_parameter, "vbmeta") == 0
+                                               )
+    {
+        erase("verifyimg", response);
+#if CONFIG_IS_ENABLED(FASTBOOT_FLASH_MMC)
+            fastboot_mmc_flash_write(verifypart, fastboot_buf_addr, image_size,
+                     response);
+#endif
+#if CONFIG_IS_ENABLED(FASTBOOT_FLASH_NAND)
+            fastboot_nand_flash_write(verifypart, fastboot_buf_addr, image_size,
+                      response);
+#endif
+        avb_ops = avb_ops_alloc(mmc_dev);
+        if (!avb_ops)
+            printf("failed to initialize verifcation");
+
+        if (avb_ops->read_is_device_unlocked(avb_ops, &unlocked) !=
+            AVB_IO_RESULT_OK) {
+            printf("Can't determine device lock state.\n");
+        }
+ slot_result =
+            avb_slot_verify(avb_ops,
+                    requested_partitions,
+                    slot_suffix,
+                    unlocked,
+                    AVB_HASHTREE_ERROR_MODE_RESTART_AND_INVALIDATE,
+                    &out_data);
+        switch (slot_result) {
+            case AVB_SLOT_VERIFY_RESULT_OK:
+                printf("flash Verification passed successfully\n");
+                goto flash;
+            case AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION:
+                printf("flash AVB_SLOT_VERIFY_RESULT_ERROR_VERIFICATION\n");
+                break;
+            case AVB_SLOT_VERIFY_RESULT_ERROR_IO:
+                printf("flash I/O error occurred during verification\n");
+                break;
+            case AVB_SLOT_VERIFY_RESULT_ERROR_OOM:
+                printf("flash OOM error occurred during verification\n");
+                break;
+            case AVB_SLOT_VERIFY_RESULT_ERROR_INVALID_METADATA:
+                printf("flash Corrupted dm-verity metadata detected\n");
+                break;
+            case AVB_SLOT_VERIFY_RESULT_ERROR_UNSUPPORTED_VERSION:
+                printf("flash Unsupported version avbtool was used\n");
+                break;
+            case AVB_SLOT_VERIFY_RESULT_ERROR_ROLLBACK_INDEX:
+                printf("flash Checking rollback index failed\n");
+                break;
+            case AVB_SLOT_VERIFY_RESULT_ERROR_PUBLIC_KEY_REJECTED:
+                flash_err = 1;
+                printf("flash Public key was rejected\n");
+                goto fl_err;
+                break;
+            default:
+                printf("flash Unknown error occurred\n");
+
+flash:
+ dev_desc = blk_get_devnum_by_type(IF_TYPE_MMC, curr_device);
+            blk = get_part_start_lba(dev_desc, "verifyimg", 0);
+            if (strcmp(cmd_parameter, "recovery") == 0) {
+                start_lba = get_part_start_lba(dev_desc, "recovery", 0);
+                end_lba = get_part_start_lba(dev_desc, "recovery", 1);
+                cnt = (end_lba - start_lba)+1;
+                cnt_actual = cnt;
+            }
+            else if (strcmp(cmd_parameter, "boot") == 0) {
+                start_lba = get_part_start_lba(dev_desc, "boot", 0);
+                end_lba = get_part_start_lba(dev_desc, "boot", 1);
+                cnt = (end_lba - start_lba)+1;
+                cnt_actual = cnt;
+            }
+            else if (strcmp(cmd_parameter, "dtbo") == 0) {
+                start_lba = get_part_start_lba(dev_desc, "dtbo", 0);
+                end_lba = get_part_start_lba(dev_desc, "dtbo", 1);
+                cnt = (end_lba - start_lba)+1;
+                cnt_actual = cnt;
+            }
+            else if (strcmp(cmd_parameter, "vbmeta") == 0) {
+                start_lba = get_part_start_lba(dev_desc, "vbmeta", 0);
+                end_lba = get_part_start_lba(dev_desc, "vbmeta", 1);
+                cnt = (end_lba - start_lba)+1;
+                cnt_actual = cnt;
+            }
+            else if (strcmp(cmd_parameter, "vendor") == 0) {
+                start_lba = get_part_start_lba(dev_desc, "vendor", 0);
+                end_lba = get_part_start_lba(dev_desc, "vendor", 1);
+                cnt_actual = (end_lba - start_lba)+1;
+                cnt = 98304;
+            }
+            addr = (void *)calloc(cnt, 512);
+            mmc = temp_init_mmc_device(curr_device, false);
+            if (!mmc)
+                printf("error mmc\n");
+
+             if(!addr)
+                 printf("\nmemory could not be allocated for %d blocks",cnt);
+
+            n=0,temp_cnt=cnt_actual;
+            blk_vimg = blk;
+            blk_part = start_lba;
+            while(temp_cnt > 0){
+ printf("\n MMC read: dev # %d, block # %d, count %d ...actualCnt=%d",curr_device, blk_vimg, cnt,cnt_actual);
+            n = blk_dread(mmc_get_blk_desc(mmc), blk_vimg, cnt, addr);
+            printf("\nMMC write: dev # %d, block # %d, count %d ... ",
+                               curr_device, blk_part, cnt);
+
+            if (mmc_getwp(mmc) == 1) {
+                printf("Error: card is write protected!\n");
+            }
+            n = blk_dwrite(mmc_get_blk_desc(mmc), blk_part, cnt, addr);
+            printf("%d blocks written: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+            temp_cnt = temp_cnt - n;
+            blk_vimg = blk_vimg+cnt;
+            blk_part = blk_part+cnt;
+            if(temp_cnt < cnt )
+                cnt = temp_cnt;
+            }
+
+            flash_err =0;//no errors
+        }
+
+fl_err:
+        if (out_data)
+            avb_slot_verify_data_free(out_data);
+
+        if(addr)
+            free(addr);
+
+          if (flash_err == 1) {
+              flash_err = 0;
+              fastboot_fail("Please sign the images with Credence Key!",response);
+          } else if (flash_err==0 ) {
+            fastboot_okay(NULL, response);
+          } else {
+              fastboot_fail("Flashing Failed!",response);
+          }
+
+
+    } else { //no verification required normal flashing
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH_MMC)
-	fastboot_mmc_flash_write(cmd_parameter, fastboot_buf_addr, image_size,
-				 response);
+            fastboot_mmc_flash_write(cmd_parameter, fastboot_buf_addr, image_size,
+                     response);
 #endif
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH_NAND)
-	fastboot_nand_flash_write(cmd_parameter, fastboot_buf_addr, image_size,
-				  response);
+            fastboot_nand_flash_write(cmd_parameter, fastboot_buf_addr, image_size,
+                      response);
 #endif
+    }
+} else
+       fastboot_fail("Device is Locked!",response);
+
 }
 
 /**
@@ -333,12 +554,17 @@ static void flash(char *cmd_parameter, char *response)
  */
 static void erase(char *cmd_parameter, char *response)
 {
+    if(fastboot_getDevLock()==true) {
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH_MMC)
 	fastboot_mmc_erase(cmd_parameter, response);
 #endif
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH_NAND)
 	fastboot_nand_erase(cmd_parameter, response);
 #endif
+    } else { 
+         snprintf(response, sizeof(response), "Device Is Locked!");
+         fastboot_fail("Device Is Locked!",response);
+    }
 }
 #endif
 
@@ -447,18 +673,52 @@ static void reboot_recovery(char *cmd_parameter, char *response)
 static void oem_format(char *cmd_parameter, char *response)
 {
 	char cmdbuf[32];
+    if(fastboot_getDevLock()==true) {
+    	if (!env_get("partitions")) {
+	    	fastboot_fail("partitions not set", response);
+    	} else {
+	    	sprintf(cmdbuf, "gpt write mmc %x $partitions",
+		    	CONFIG_FASTBOOT_FLASH_MMC_DEV);
+    		if (run_command(cmdbuf, 0))
+	    		fastboot_fail("", response);
+		    else
+			    fastboot_okay(NULL, response);
+	   }
+    }else {
+        snprintf(response, sizeof(response), "Device Is Locked!");
+        fastboot_fail("Device Is Locked!",response);
+    }
+}
 
-	if (!env_get("partitions")) {
-		fastboot_fail("partitions not set", response);
-	} else {
-		sprintf(cmdbuf, "gpt write mmc %x $partitions",
-			CONFIG_FASTBOOT_FLASH_MMC_DEV);
-		if (run_command(cmdbuf, 0))
-			fastboot_fail("", response);
-		else
-			fastboot_okay(NULL, response);
-	}
+static void oem_lock(char *cmd_parameter, char *response)
+{
+    fastboot_setDevLock(false);
+    snprintf(response, sizeof(response), "Device Is Locked!");
+    fastboot_info("Device Is Locked!",response);
+    fastboot_okay("Device Is Locked!",response);
+}
+
+static void oem_unlock(char *cmd_parameter, char *response)
+{
+    if (!strcmp(cmd_parameter, UNLOCK_CREDENCE_KEY)) {
+        fastboot_setDevLock(true);
+        snprintf(response, sizeof(response), "Valid Key!");
+        fastboot_info("Valid Key!",response);
+        fastboot_okay("Valid Key!",response);
+    } else {
+        snprintf(response, sizeof(response), "Invalid Key!");
+        fastboot_fail("Invalid Key!",response);
+    }
+}
+
+static void oem_deviceinfo(char *cmd_parameter, char *response)
+{
+    char reason[100];
+    snprintf(reason, sizeof(reason), "\tDevice unlocked: %s", (fastboot_getDevLock() ? "true" : "false"));
+    fastboot_info(reason,response);
+    fastboot_okay(reason,response);
 }
+
 #endif
 
 #if CONFIG_IS_ENABLED(FASTBOOT_CMD_OEM_PARTCONF)
diff --git a/drivers/fastboot/fb_common.c b/drivers/fastboot/fb_common.c
index ef399d0c4ab..00c55a25570 100644
--- a/drivers/fastboot/fb_common.c
+++ b/drivers/fastboot/fb_common.c
@@ -16,6 +16,11 @@
 #include <env.h>
 #include <fastboot.h>
 #include <net/fastboot.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm-generic/gpio.h>
+#include <asm/mach-imx/gpio.h>
+
+//#define GP_LED_VIBRATOR    IMX_GPIO_NR(3, 24)
 
 /**
  * fastboot_buf_addr - base address of the fastboot download buffer
@@ -79,6 +84,22 @@ void fastboot_okay(const char *reason, char *response)
 		fastboot_response("OKAY", response, NULL);
 }
 
+void fastboot_info(const char *reason, char *response)
+{
+   fastboot_response("INFO", response, "%s", reason);
+}
+
+void fastboot_setDevLock(bool status)
+{
+    is_unlocked = status;
+}
+
+bool fastboot_getDevLock(void)
+{
+    return is_unlocked;
+}
+
+
 /**
  * fastboot_set_reboot_flag() - Set flag to indicate reboot-bootloader
  *
@@ -178,6 +199,7 @@ void fastboot_set_progress_callback(void (*progress)(const char *msg))
  */
 void fastboot_init(void *buf_addr, u32 buf_size)
 {
+   // gpio_set_value(GP_LED_VIBRATOR, 1);
 	fastboot_buf_addr = buf_addr ? buf_addr :
 				       (void *)CONFIG_FASTBOOT_BUF_ADDR;
 	fastboot_buf_size = buf_size ? buf_size : CONFIG_FASTBOOT_BUF_SIZE;
diff --git a/drivers/fastboot/fb_getvar.c b/drivers/fastboot/fb_getvar.c
index f8140ef1b3f..6187010aef1 100644
--- a/drivers/fastboot/fb_getvar.c
+++ b/drivers/fastboot/fb_getvar.c
@@ -28,6 +28,7 @@ static void getvar_version_baseband(char *var_parameter, char *response);
 static void getvar_product(char *var_parameter, char *response);
 static void getvar_platform(char *var_parameter, char *response);
 static void getvar_current_slot(char *var_parameter, char *response);
+static void get_var_deviceinfo(char *var_parameter, char *response);
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH)
 static void getvar_has_slot(char *var_parameter, char *response);
 #endif
@@ -96,7 +97,10 @@ static const struct {
 	}, {
 		.variable = "mem-size",
 		.dispatch = getvar_mem_size
-	}
+	}, {
+        .variable = "device-info",
+        .dispatch = get_var_deviceinfo
+    }
 };
 
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH)
@@ -140,6 +144,14 @@ static int getvar_get_part_info(const char *part_name, char *response,
 }
 #endif
 
+static void get_var_deviceinfo(char *var_parameter, char *response)
+{
+    char unlocked[100];
+    snprintf(unlocked,sizeof(unlocked),"\tDevice Unlocked = %s",(fastboot_getDevLock() ? "true" : "false"));
+    fastboot_okay(unlocked, response);
+}
+
+
 static void getvar_version(char *var_parameter, char *response)
 {
 	fastboot_okay(FASTBOOT_VERSION, response);
diff --git a/include/configs/c2-imx8mm.h b/include/configs/c2-imx8mm.h
index a943d4d8757..ceaab158618 100644
--- a/include/configs/c2-imx8mm.h
+++ b/include/configs/c2-imx8mm.h
@@ -166,6 +166,7 @@
 #define BD_FUSE_MAC1B_STR	"fuse_mac1b=" BD_FUSE_MAC1B "\0"
 
 #define CONFIG_EXTRA_ENV_SETTINGS \
+    "bootdelay=0\0" \
 	"console=" BD_CONSOLE "\0" \
 	"env_dev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
 	"env_part=" __stringify(CONFIG_SYS_MMC_ENV_PART) "\0" \
@@ -188,6 +189,7 @@
 	"m4loadaddr="__stringify(CONFIG_IMX_MCORE_TCM_ADDR)"\0" \
 	"mcore_bootargs=clk-imx8mm.mcore_booted\0" \
 	"otg_upgradeu=run usbnetwork; tftp " BD_RAM_SCRIPT " net_upgradeu.scr && source " BD_RAM_SCRIPT "\0" \
+	"splashpos=m,m\0" \
 	"upgradeu=setenv boot_scripts upgrade.scr; boot;" \
 		"echo Upgrade failed!; setenv boot_scripts boot.scr\0" \
 	"usbnet_devaddr=00:19:b8:00:00:02\0" \
diff --git a/include/fastboot.h b/include/fastboot.h
index 57daaf12982..45dfa884346 100644
--- a/include/fastboot.h
+++ b/include/fastboot.h
@@ -37,6 +37,9 @@ enum {
 	FASTBOOT_COMMAND_SET_ACTIVE,
 #if CONFIG_IS_ENABLED(FASTBOOT_CMD_OEM_FORMAT)
 	FASTBOOT_COMMAND_OEM_FORMAT,
+    	FASTBOOT_COMMAND_OEM_LOCK,
+    	FASTBOOT_COMMAND_OEM_UNLOCK,
+   	FASTBOOT_COMMAND_OEM_DEVICEINFO,
 #endif
 #if CONFIG_IS_ENABLED(FASTBOOT_CMD_OEM_PARTCONF)
 	FASTBOOT_COMMAND_OEM_PARTCONF,
@@ -62,6 +65,13 @@ enum fastboot_reboot_reason {
 	FASTBOOT_REBOOT_REASONS_COUNT
 };
 
+
+#if CONFIG_IS_ENABLED(FASTBOOT_CMD_OEM_FORMAT)
+static bool is_unlocked=false;
+#else
+static bool is_unlocked=true;
+#endif
+
 /**
  * fastboot_response() - Writes a response of the form "$tag$reason".
  *
@@ -89,6 +99,14 @@ void fastboot_fail(const char *reason, char *response);
  */
 void fastboot_okay(const char *reason, char *response);
 
+void fastboot_info(const char *reason, char *response);
+
+/**
+ *  * to set and get the OEM device unlock flag
+ *   * */
+void fastboot_setDevLock(bool status);
+bool fastboot_getDevLock(void);
+
 /**
  * fastboot_set_reboot_flag() - Set flag to indicate reboot-bootloader
  *
diff --git a/include/mmc.h b/include/mmc.h
index e4a6d2e5a4b..18dd8d63dbf 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -958,6 +958,7 @@ void mmc_set_preinit(struct mmc *mmc, int preinit);
 
 #define mmc_dev(x)	((x)->dev)
 
+struct mmc *temp_init_mmc_device(int curr_dev, bool val);
 void board_mmc_power_init(void);
 int board_mmc_init(struct bd_info *bis);
 int cpu_mmc_init(struct bd_info *bis);
diff --git a/include/part.h b/include/part.h
index 53cfbdd8767..40a29421d28 100644
--- a/include/part.h
+++ b/include/part.h
@@ -467,6 +467,8 @@ int gpt_verify_partitions(struct blk_desc *dev_desc,
  */
 int get_disk_guid(struct blk_desc *dev_desc, char *guid);
 
+__le64 get_part_start_lba(struct blk_desc *dev_desc, char* part_name, int required_address);
+
 #endif
 
 #if CONFIG_IS_ENABLED(DOS_PARTITION)
diff --git a/lib/libavb/avb_slot_verify.c b/lib/libavb/avb_slot_verify.c
index ae8e1dffa4c..1c04cfa2f3f 100644
--- a/lib/libavb/avb_slot_verify.c
+++ b/lib/libavb/avb_slot_verify.c
@@ -16,6 +16,8 @@
 #include "avb_version.h"
 #include <log.h>
 #include <malloc.h>
+#include <blk.h>
+#include <part.h>
 
 /* Maximum number of partitions that can be loaded with avb_slot_verify(). */
 #define MAX_NUMBER_OF_LOADED_PARTITIONS 32
@@ -26,6 +28,8 @@
 /* Maximum size of a vbmeta image - 64 KiB. */
 #define VBMETA_MAX_SIZE (64 * 1024)
 
+int verifyfg = 0;
+
 static AvbSlotVerifyResult initialize_persistent_digest(
     AvbOps* ops,
     const char* part_name,
@@ -537,6 +541,15 @@ out:
   return ret;
 }
 
+static unsigned int get_partition_size(char* partition) {
+    struct blk_desc *dev_desc;
+    int start_lba, end_lba, curr_device = 0;
+    dev_desc = blk_get_devnum_by_type(IF_TYPE_MMC, curr_device);
+    start_lba = get_part_start_lba(dev_desc, partition, 0);
+    end_lba = get_part_start_lba(dev_desc, partition, 1);
+    return (((end_lba-start_lba)+1)*512); 
+}
+
 static AvbSlotVerifyResult load_and_verify_vbmeta(
     AvbOps* ops,
     const char* const* requested_partitions,
@@ -571,6 +584,8 @@ static AvbSlotVerifyResult load_and_verify_vbmeta(
   bool look_for_vbmeta_footer;
   AvbVBMetaData* vbmeta_image_data = NULL;
 
+  char fastboot_partname[AVB_PART_NAME_MAX_SIZE];
+  
   ret = AVB_SLOT_VERIFY_RESULT_OK;
 
   avb_assert(slot_data != NULL);
@@ -591,7 +606,16 @@ static AvbSlotVerifyResult load_and_verify_vbmeta(
    */
   look_for_vbmeta_footer = true;
   if (avb_strncmp(partition_name, "vbmeta", avb_strlen("vbmeta")) == 0) {
+     if ((avb_strncmp(requested_partitions[0], "verifyimg", avb_strlen("verifyimg")) == 0) &&
+            (avb_strncmp(requested_partitions[1], "vbmeta", avb_strlen("vbmeta")) == 0)) {
+        partition_name = requested_partitions[0];
+        partition_name_len = avb_strlen("verifyimg");
+    }
+
     look_for_vbmeta_footer = false;
+  } else if ((avb_strncmp(requested_partitions[0], "verifyimg", avb_strlen("verifyimg")) == 0)) {
+    partition_name = requested_partitions[0];
+    partition_name_len = avb_strlen("verifyimg");
   }
 
   if (!avb_validate_utf8((const uint8_t*)partition_name, partition_name_len)) {
@@ -623,11 +647,29 @@ static AvbSlotVerifyResult load_and_verify_vbmeta(
   if (look_for_vbmeta_footer) {
     uint8_t footer_buf[AVB_FOOTER_SIZE];
     size_t footer_num_read;
+    int avb_footer_size = AVB_FOOTER_SIZE;
+    unsigned int verifyimg_size = 0, part_size = 0;
     AvbFooter footer;
 
+  if (avb_strcmp(requested_partitions[0], "verifyimg") == 0) {
+       verifyimg_size = get_partition_size("verifyimg"); 
+        if (avb_strcmp(requested_partitions[1], "recovery") == 0) {
+            part_size = get_partition_size("recovery");
+            avb_footer_size = avb_footer_size + (verifyimg_size - part_size);
+        }
+        else if (avb_strcmp(requested_partitions[1], "boot") == 0) {
+            part_size = get_partition_size("boot");
+            avb_footer_size = avb_footer_size + (verifyimg_size - part_size);
+        }
+        if (avb_strcmp(requested_partitions[1], "dtbo") == 0) {
+            part_size = get_partition_size("dtbo");
+            avb_footer_size = avb_footer_size + (verifyimg_size - part_size);
+        }
+   }
+
     io_ret = ops->read_from_partition(ops,
                                       full_partition_name,
-                                      -AVB_FOOTER_SIZE,
+                                      -avb_footer_size,
                                       AVB_FOOTER_SIZE,
                                       footer_buf,
                                       &footer_num_read);
@@ -930,6 +972,7 @@ static AvbSlotVerifyResult load_and_verify_vbmeta(
    *   image, verify vbmeta image (includes rollback checks, hash
    *   checks, bail on chained partitions).
    */
+  if ( verifyfg != 1) {
   descriptors =
       avb_descriptor_get_all(vbmeta_buf, vbmeta_num_read, &num_descriptors);
   for (n = 0; n < num_descriptors; n++) {
@@ -994,6 +1037,12 @@ static AvbSlotVerifyResult load_and_verify_vbmeta(
         chain_partition_name = ((const uint8_t*)descriptors[n]) +
                                sizeof(AvbChainPartitionDescriptor);
         chain_public_key = chain_partition_name + chain_desc.partition_name_len;
+        if (avb_strcmp(requested_partitions[0], "verifyimg") == 0)
+        {
+        strcpy(fastboot_partname, (const char*)chain_partition_name);
+        if (avb_strcmp(fastboot_partname, requested_partitions[1]) == 0)
+        {
+        verifyfg = 1;
 
         sub_ret =
             load_and_verify_vbmeta(ops,
@@ -1016,6 +1065,31 @@ static AvbSlotVerifyResult load_and_verify_vbmeta(
             goto out;
           }
         }
+        }
+       } else {
+        sub_ret =
+            load_and_verify_vbmeta(ops,
+                                   requested_partitions,
+                                   ab_suffix,
+                                   flags,
+                                   allow_verification_error,
+                                   toplevel_vbmeta_flags,
+                                   chain_desc.rollback_index_location,
+                                   (const char*)chain_partition_name,
+                                   chain_desc.partition_name_len,
+                                   chain_public_key,
+                                   chain_desc.public_key_len,
+                                   slot_data,
+                                   NULL, /* out_algorithm_type */
+                                   NULL /* out_additional_cmdline_subst */);
+        if (sub_ret != AVB_SLOT_VERIFY_RESULT_OK) {
+          ret = sub_ret;
+          if (!result_should_continue(ret)) {
+            goto out;
+          }
+        }
+               }
+
       } break;
 
       case AVB_DESCRIPTOR_TAG_KERNEL_CMDLINE: {
@@ -1188,6 +1262,7 @@ static AvbSlotVerifyResult load_and_verify_vbmeta(
     }
   }
 
+}
   if (rollback_index_location < 0 ||
       rollback_index_location >= AVB_MAX_NUMBER_OF_ROLLBACK_INDEX_LOCATIONS) {
     avb_errorv(
@@ -1215,6 +1290,8 @@ out:
   if (descriptors != NULL) {
     avb_free(descriptors);
   }
+
+  verifyfg = 0;
   return ret;
 }
 
